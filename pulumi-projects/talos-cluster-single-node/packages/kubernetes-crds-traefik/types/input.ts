// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import type * as pulumi from "@pulumi/pulumi";
import type * as inputs from "./input";
import * as outputs from "./output";

export namespace hub {
	export namespace v1alpha1 {
		/**
		 * AIService is a Kubernetes-like Service to interact with a text-based LLM provider. It defines the parameters and credentials required to interact with various LLM providers.
		 */
		export interface AIService {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"AIService">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpec>;
		}

		/**
		 * The desired behavior of this AIService.
		 */
		export interface AIServiceSpec {
			anthropic?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAnthropic>;
			azureOpenai?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAzureOpenai>;
			bedrock?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecBedrock>;
			cohere?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecCohere>;
			deepSeek?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecDeepSeek>;
			gemini?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecGemini>;
			mistral?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecMistral>;
			ollama?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOllama>;
			openai?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOpenai>;
			qWen?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecQWen>;
		}

		/**
		 * Anthropic configures Anthropic backend.
		 */
		export interface AIServiceSpecAnthropic {
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAnthropicParams>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAnthropicToken>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecAnthropicParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecAnthropicParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Anthropic configures Anthropic backend.
		 */
		export interface AIServiceSpecAnthropicPatch {
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAnthropicParamsPatch>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAnthropicTokenPatch>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecAnthropicToken {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecAnthropicTokenPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * AzureOpenAI configures AzureOpenAI.
		 */
		export interface AIServiceSpecAzureOpenai {
			apiKeySecret?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAzureOpenaiApiKeySecret>;
			baseUrl?: pulumi.Input<string>;
			deploymentName?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAzureOpenaiParams>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecAzureOpenaiApiKeySecret {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecAzureOpenaiApiKeySecretPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecAzureOpenaiParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecAzureOpenaiParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * AzureOpenAI configures AzureOpenAI.
		 */
		export interface AIServiceSpecAzureOpenaiPatch {
			apiKeySecret?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAzureOpenaiApiKeySecretPatch>;
			baseUrl?: pulumi.Input<string>;
			deploymentName?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAzureOpenaiParamsPatch>;
		}

		/**
		 * Bedrock configures Bedrock backend.
		 */
		export interface AIServiceSpecBedrock {
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecBedrockParams>;
			region?: pulumi.Input<string>;
			systemMessage?: pulumi.Input<boolean>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecBedrockParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecBedrockParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Bedrock configures Bedrock backend.
		 */
		export interface AIServiceSpecBedrockPatch {
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecBedrockParamsPatch>;
			region?: pulumi.Input<string>;
			systemMessage?: pulumi.Input<boolean>;
		}

		/**
		 * Cohere configures Cohere backend.
		 */
		export interface AIServiceSpecCohere {
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecCohereParams>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecCohereToken>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecCohereParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecCohereParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Cohere configures Cohere backend.
		 */
		export interface AIServiceSpecCoherePatch {
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecCohereParamsPatch>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecCohereTokenPatch>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecCohereToken {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecCohereTokenPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * DeepSeek configures DeepSeek.
		 */
		export interface AIServiceSpecDeepSeek {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecDeepSeekParams>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecDeepSeekToken>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecDeepSeekParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecDeepSeekParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * DeepSeek configures DeepSeek.
		 */
		export interface AIServiceSpecDeepSeekPatch {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecDeepSeekParamsPatch>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecDeepSeekTokenPatch>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecDeepSeekToken {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecDeepSeekTokenPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * Gemini configures Gemini backend.
		 */
		export interface AIServiceSpecGemini {
			apiKey?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecGeminiApiKey>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecGeminiParams>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecGeminiApiKey {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecGeminiApiKeyPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecGeminiParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecGeminiParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Gemini configures Gemini backend.
		 */
		export interface AIServiceSpecGeminiPatch {
			apiKey?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecGeminiApiKeyPatch>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecGeminiParamsPatch>;
		}

		/**
		 * Mistral configures Mistral AI backend.
		 */
		export interface AIServiceSpecMistral {
			apiKey?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecMistralApiKey>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecMistralParams>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecMistralApiKey {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecMistralApiKeyPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecMistralParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecMistralParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Mistral configures Mistral AI backend.
		 */
		export interface AIServiceSpecMistralPatch {
			apiKey?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecMistralApiKeyPatch>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecMistralParamsPatch>;
		}

		/**
		 * Ollama configures Ollama backend.
		 */
		export interface AIServiceSpecOllama {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOllamaParams>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecOllamaParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecOllamaParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Ollama configures Ollama backend.
		 */
		export interface AIServiceSpecOllamaPatch {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOllamaParamsPatch>;
		}

		/**
		 * OpenAI configures OpenAI.
		 */
		export interface AIServiceSpecOpenai {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOpenaiParams>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOpenaiToken>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecOpenaiParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecOpenaiParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * OpenAI configures OpenAI.
		 */
		export interface AIServiceSpecOpenaiPatch {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOpenaiParamsPatch>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOpenaiTokenPatch>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecOpenaiToken {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecOpenaiTokenPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * The desired behavior of this AIService.
		 */
		export interface AIServiceSpecPatch {
			anthropic?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAnthropicPatch>;
			azureOpenai?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecAzureOpenaiPatch>;
			bedrock?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecBedrockPatch>;
			cohere?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecCoherePatch>;
			deepSeek?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecDeepSeekPatch>;
			gemini?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecGeminiPatch>;
			mistral?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecMistralPatch>;
			ollama?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOllamaPatch>;
			openai?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecOpenaiPatch>;
			qWen?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecQWenPatch>;
		}

		/**
		 * QWen configures QWen.
		 */
		export interface AIServiceSpecQWen {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecQWenParams>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecQWenToken>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecQWenParams {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * Params holds the LLM hyperparameters.
		 */
		export interface AIServiceSpecQWenParamsPatch {
			frequencyPenalty?: pulumi.Input<number>;
			maxTokens?: pulumi.Input<number>;
			presencePenalty?: pulumi.Input<number>;
			temperature?: pulumi.Input<number>;
			topP?: pulumi.Input<number>;
		}

		/**
		 * QWen configures QWen.
		 */
		export interface AIServiceSpecQWenPatch {
			baseUrl?: pulumi.Input<string>;
			model?: pulumi.Input<string>;
			params?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecQWenParamsPatch>;
			token?: pulumi.Input<inputs.hub.v1alpha1.AIServiceSpecQWenTokenPatch>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecQWenToken {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * SecretReference references a kubernetes secret.
		 */
		export interface AIServiceSpecQWenTokenPatch {
			secretName?: pulumi.Input<string>;
		}

		/**
		 * API defines an HTTP interface that is exposed to external clients. It specifies the supported versions
		 * and provides instructions for accessing its documentation. Once instantiated, an API object is associated
		 * with an Ingress, IngressRoute, or HTTPRoute resource, enabling the exposure of the described API to the outside world.
		 */
		export interface API {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"API">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APISpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIStatus>;
		}

		/**
		 * APIAuth defines the authentication configuration for APIs.
		 */
		export interface APIAuth {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APIAuth">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APIAuthSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIAuthStatus>;
		}

		/**
		 * The desired behavior of this APIAuth.
		 */
		export interface APIAuthSpec {
			/**
			 * APIKey configures API key authentication.
			 */
			apiKey?: pulumi.Input<{ [key: string]: any }>;
			/**
			 * IsDefault specifies if this APIAuth should be used as the default API authentication method for the namespace.
			 * Only one APIAuth per namespace should have isDefault set to true.
			 */
			isDefault?: pulumi.Input<boolean>;
			jwt?: pulumi.Input<inputs.hub.v1alpha1.APIAuthSpecJwt>;
		}

		/**
		 * JWT configures JWT authentication.
		 */
		export interface APIAuthSpecJwt {
			/**
			 * AppIDClaim is the name of the claim holding the identifier of the application.
			 * This field is sometimes named `client_id`.
			 */
			appIdClaim?: pulumi.Input<string>;
			/**
			 * ForwardHeaders specifies additional headers to forward with the request.
			 */
			forwardHeaders?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * JWKSFile contains the JWKS file content for JWT verification.
			 */
			jwksFile?: pulumi.Input<string>;
			/**
			 * JWKSURL is the URL to fetch the JWKS for JWT verification.
			 */
			jwksUrl?: pulumi.Input<string>;
			/**
			 * PublicKey is the PEM-encoded public key for JWT verification.
			 */
			publicKey?: pulumi.Input<string>;
			/**
			 * SigningSecretName is the name of the Kubernetes Secret containing the signing secret.
			 * The secret must be of type Opaque and contain a key named 'value'.
			 */
			signingSecretName?: pulumi.Input<string>;
			/**
			 * StripAuthorizationHeader determines whether to strip the Authorization header before forwarding the request.
			 */
			stripAuthorizationHeader?: pulumi.Input<boolean>;
			/**
			 * TokenNameClaim is the name of the claim holding the name of the token.
			 * This name, if provided, will be used in the metrics.
			 */
			tokenNameClaim?: pulumi.Input<string>;
			/**
			 * TokenQueryKey specifies the query parameter name for the JWT token.
			 */
			tokenQueryKey?: pulumi.Input<string>;
		}

		/**
		 * JWT configures JWT authentication.
		 */
		export interface APIAuthSpecJwtPatch {
			/**
			 * AppIDClaim is the name of the claim holding the identifier of the application.
			 * This field is sometimes named `client_id`.
			 */
			appIdClaim?: pulumi.Input<string>;
			/**
			 * ForwardHeaders specifies additional headers to forward with the request.
			 */
			forwardHeaders?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * JWKSFile contains the JWKS file content for JWT verification.
			 */
			jwksFile?: pulumi.Input<string>;
			/**
			 * JWKSURL is the URL to fetch the JWKS for JWT verification.
			 */
			jwksUrl?: pulumi.Input<string>;
			/**
			 * PublicKey is the PEM-encoded public key for JWT verification.
			 */
			publicKey?: pulumi.Input<string>;
			/**
			 * SigningSecretName is the name of the Kubernetes Secret containing the signing secret.
			 * The secret must be of type Opaque and contain a key named 'value'.
			 */
			signingSecretName?: pulumi.Input<string>;
			/**
			 * StripAuthorizationHeader determines whether to strip the Authorization header before forwarding the request.
			 */
			stripAuthorizationHeader?: pulumi.Input<boolean>;
			/**
			 * TokenNameClaim is the name of the claim holding the name of the token.
			 * This name, if provided, will be used in the metrics.
			 */
			tokenNameClaim?: pulumi.Input<string>;
			/**
			 * TokenQueryKey specifies the query parameter name for the JWT token.
			 */
			tokenQueryKey?: pulumi.Input<string>;
		}

		/**
		 * The desired behavior of this APIAuth.
		 */
		export interface APIAuthSpecPatch {
			/**
			 * APIKey configures API key authentication.
			 */
			apiKey?: pulumi.Input<{ [key: string]: any }>;
			/**
			 * IsDefault specifies if this APIAuth should be used as the default API authentication method for the namespace.
			 * Only one APIAuth per namespace should have isDefault set to true.
			 */
			isDefault?: pulumi.Input<boolean>;
			jwt?: pulumi.Input<inputs.hub.v1alpha1.APIAuthSpecJwtPatch>;
		}

		/**
		 * The current status of this APIAuth.
		 */
		export interface APIAuthStatus {
			/**
			 * Hash is a hash representing the APIAuth.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * APIBundle defines a set of APIs.
		 */
		export interface APIBundle {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APIBundle">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APIBundleSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIBundleStatus>;
		}

		/**
		 * The desired behavior of this APIBundle.
		 */
		export interface APIBundleSpec {
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.APIBundleSpecApiSelector>;
			/**
			 * APIs defines a set of APIs that will be accessible to the configured audience.
			 * Multiple APIBundles can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIBundleSpecApis>[]
			>;
			/**
			 * Title is the human-readable name of the APIBundle that will be used on the portal.
			 */
			title?: pulumi.Input<string>;
		}

		/**
		 * APISelector selects the APIs that will be accessible to the configured audience.
		 * Multiple APIBundles can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface APIBundleSpecApiSelector {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIBundleSpecApiSelectorMatchExpressions>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface APIBundleSpecApiSelectorMatchExpressions {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface APIBundleSpecApiSelectorMatchExpressionsPatch {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * APISelector selects the APIs that will be accessible to the configured audience.
		 * Multiple APIBundles can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface APIBundleSpecApiSelectorPatch {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIBundleSpecApiSelectorMatchExpressionsPatch>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface APIBundleSpecApis {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface APIBundleSpecApisPatch {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * The desired behavior of this APIBundle.
		 */
		export interface APIBundleSpecPatch {
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.APIBundleSpecApiSelectorPatch>;
			/**
			 * APIs defines a set of APIs that will be accessible to the configured audience.
			 * Multiple APIBundles can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIBundleSpecApisPatch>[]
			>;
			/**
			 * Title is the human-readable name of the APIBundle that will be used on the portal.
			 */
			title?: pulumi.Input<string>;
		}

		/**
		 * The current status of this APIBundle.
		 */
		export interface APIBundleStatus {
			/**
			 * Hash is a hash representing the APIBundle.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * APICatalogItem defines APIs that will be part of the API catalog on the portal.
		 */
		export interface APICatalogItem {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APICatalogItem">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemStatus>;
		}

		/**
		 * The desired behavior of this APICatalogItem.
		 */
		export interface APICatalogItemSpec {
			/**
			 * APIBundles defines a set of APIBundle that will be visible to the configured audience.
			 * Multiple APICatalogItem can select the same APIBundles.
			 */
			apiBundles?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiBundles>[]
			>;
			apiPlan?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiPlan>;
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiSelector>;
			/**
			 * APIs defines a set of APIs that will be visible to the configured audience.
			 * Multiple APICatalogItem can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApis>[]
			>;
			/**
			 * Everyone indicates that all users will see these APIs.
			 */
			everyone?: pulumi.Input<boolean>;
			/**
			 * Groups are the consumer groups that will see the APIs.
			 */
			groups?: pulumi.Input<pulumi.Input<string>[]>;
			operationFilter?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecOperationFilter>;
		}

		/**
		 * APIBundleReference references an APIBundle.
		 */
		export interface APICatalogItemSpecApiBundles {
			/**
			 * Name of the APIBundle.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIBundleReference references an APIBundle.
		 */
		export interface APICatalogItemSpecApiBundlesPatch {
			/**
			 * Name of the APIBundle.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIPlan defines which APIPlan will be available.
		 * If multiple APICatalogItem specify the same API with different APIPlan, the API consumer will be able to pick
		 * a plan from this list.
		 */
		export interface APICatalogItemSpecApiPlan {
			/**
			 * Name of the APIPlan.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIPlan defines which APIPlan will be available.
		 * If multiple APICatalogItem specify the same API with different APIPlan, the API consumer will be able to pick
		 * a plan from this list.
		 */
		export interface APICatalogItemSpecApiPlanPatch {
			/**
			 * Name of the APIPlan.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APISelector selects the APIs that will be visible to the configured audience.
		 * Multiple APICatalogItem can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface APICatalogItemSpecApiSelector {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiSelectorMatchExpressions>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface APICatalogItemSpecApiSelectorMatchExpressions {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface APICatalogItemSpecApiSelectorMatchExpressionsPatch {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * APISelector selects the APIs that will be visible to the configured audience.
		 * Multiple APICatalogItem can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface APICatalogItemSpecApiSelectorPatch {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiSelectorMatchExpressionsPatch>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface APICatalogItemSpecApis {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface APICatalogItemSpecApisPatch {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * OperationFilter specifies the visible operations on APIs and APIVersions.
		 * If not set, all operations are available.
		 * An empty OperationFilter prohibits all operations.
		 */
		export interface APICatalogItemSpecOperationFilter {
			/**
			 * Include defines the names of OperationSets that will be accessible.
			 */
			include?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * OperationFilter specifies the visible operations on APIs and APIVersions.
		 * If not set, all operations are available.
		 * An empty OperationFilter prohibits all operations.
		 */
		export interface APICatalogItemSpecOperationFilterPatch {
			/**
			 * Include defines the names of OperationSets that will be accessible.
			 */
			include?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * The desired behavior of this APICatalogItem.
		 */
		export interface APICatalogItemSpecPatch {
			/**
			 * APIBundles defines a set of APIBundle that will be visible to the configured audience.
			 * Multiple APICatalogItem can select the same APIBundles.
			 */
			apiBundles?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiBundlesPatch>[]
			>;
			apiPlan?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiPlanPatch>;
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApiSelectorPatch>;
			/**
			 * APIs defines a set of APIs that will be visible to the configured audience.
			 * Multiple APICatalogItem can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecApisPatch>[]
			>;
			/**
			 * Everyone indicates that all users will see these APIs.
			 */
			everyone?: pulumi.Input<boolean>;
			/**
			 * Groups are the consumer groups that will see the APIs.
			 */
			groups?: pulumi.Input<pulumi.Input<string>[]>;
			operationFilter?: pulumi.Input<inputs.hub.v1alpha1.APICatalogItemSpecOperationFilterPatch>;
		}

		/**
		 * The current status of this APICatalogItem.
		 */
		export interface APICatalogItemStatus {
			/**
			 * Hash is a hash representing the APICatalogItem.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * APIPlan defines API Plan policy.
		 */
		export interface APIPlan {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APIPlan">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APIPlanSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIPlanStatus>;
		}

		/**
		 * The desired behavior of this APIPlan.
		 */
		export interface APIPlanSpec {
			/**
			 * Description describes the plan.
			 */
			description?: pulumi.Input<string>;
			quota?: pulumi.Input<inputs.hub.v1alpha1.APIPlanSpecQuota>;
			rateLimit?: pulumi.Input<inputs.hub.v1alpha1.APIPlanSpecRateLimit>;
			/**
			 * Title is the human-readable name of the plan.
			 */
			title?: pulumi.Input<string>;
		}

		/**
		 * The desired behavior of this APIPlan.
		 */
		export interface APIPlanSpecPatch {
			/**
			 * Description describes the plan.
			 */
			description?: pulumi.Input<string>;
			quota?: pulumi.Input<inputs.hub.v1alpha1.APIPlanSpecQuotaPatch>;
			rateLimit?: pulumi.Input<inputs.hub.v1alpha1.APIPlanSpecRateLimitPatch>;
			/**
			 * Title is the human-readable name of the plan.
			 */
			title?: pulumi.Input<string>;
		}

		/**
		 * Quota defines the quota policy.
		 */
		export interface APIPlanSpecQuota {
			/**
			 * Limit is the maximum number of token in the bucket.
			 */
			limit?: pulumi.Input<number>;
			/**
			 * Period is the unit of time for the Limit.
			 */
			period?: pulumi.Input<string>;
		}

		/**
		 * Quota defines the quota policy.
		 */
		export interface APIPlanSpecQuotaPatch {
			/**
			 * Limit is the maximum number of token in the bucket.
			 */
			limit?: pulumi.Input<number>;
			/**
			 * Period is the unit of time for the Limit.
			 */
			period?: pulumi.Input<string>;
		}

		/**
		 * RateLimit defines the rate limit policy.
		 */
		export interface APIPlanSpecRateLimit {
			/**
			 * Limit is the maximum number of token in the bucket.
			 */
			limit?: pulumi.Input<number>;
			/**
			 * Period is the unit of time for the Limit.
			 */
			period?: pulumi.Input<string>;
		}

		/**
		 * RateLimit defines the rate limit policy.
		 */
		export interface APIPlanSpecRateLimitPatch {
			/**
			 * Limit is the maximum number of token in the bucket.
			 */
			limit?: pulumi.Input<number>;
			/**
			 * Period is the unit of time for the Limit.
			 */
			period?: pulumi.Input<string>;
		}

		/**
		 * The current status of this APIPlan.
		 */
		export interface APIPlanStatus {
			/**
			 * Hash is a hash representing the APIPlan.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * APIPortal defines a developer portal for accessing the documentation of APIs.
		 */
		export interface APIPortal {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APIPortal">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APIPortalSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIPortalStatus>;
		}

		/**
		 * APIPortalAuth defines the authentication configuration for an APIPortal.
		 */
		export interface APIPortalAuth {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APIPortalAuth">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APIPortalAuthSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIPortalAuthStatus>;
		}

		/**
		 * The desired behavior of this APIPortalAuth.
		 */
		export interface APIPortalAuthSpec {
			oidc?: pulumi.Input<inputs.hub.v1alpha1.APIPortalAuthSpecOidc>;
		}

		/**
		 * OIDC configures the OIDC authentication.
		 */
		export interface APIPortalAuthSpecOidc {
			claims?: pulumi.Input<inputs.hub.v1alpha1.APIPortalAuthSpecOidcClaims>;
			/**
			 * IssuerURL is the OIDC provider issuer URL.
			 */
			issuerUrl?: pulumi.Input<string>;
			/**
			 * Scopes is a list of OAuth2 scopes.
			 */
			scopes?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * SecretName is the name of the Kubernetes Secret containing clientId and clientSecret keys.
			 */
			secretName?: pulumi.Input<string>;
			/**
			 * SyncedAttributes is a list of additional attributes to sync from the OIDC provider.
			 * Each attribute must correspond to a configured claim field.
			 */
			syncedAttributes?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Claims configures JWT claim mappings for user attributes.
		 */
		export interface APIPortalAuthSpecOidcClaims {
			/**
			 * Company is the JWT claim for user company.
			 */
			company?: pulumi.Input<string>;
			/**
			 * Email is the JWT claim for user email.
			 */
			email?: pulumi.Input<string>;
			/**
			 * Firstname is the JWT claim for user first name.
			 */
			firstname?: pulumi.Input<string>;
			/**
			 * Groups is the JWT claim for user groups. This field is required for authorization.
			 */
			groups?: pulumi.Input<string>;
			/**
			 * Lastname is the JWT claim for user last name.
			 */
			lastname?: pulumi.Input<string>;
			/**
			 * UserID is the JWT claim for user ID mapping.
			 */
			userId?: pulumi.Input<string>;
		}

		/**
		 * Claims configures JWT claim mappings for user attributes.
		 */
		export interface APIPortalAuthSpecOidcClaimsPatch {
			/**
			 * Company is the JWT claim for user company.
			 */
			company?: pulumi.Input<string>;
			/**
			 * Email is the JWT claim for user email.
			 */
			email?: pulumi.Input<string>;
			/**
			 * Firstname is the JWT claim for user first name.
			 */
			firstname?: pulumi.Input<string>;
			/**
			 * Groups is the JWT claim for user groups. This field is required for authorization.
			 */
			groups?: pulumi.Input<string>;
			/**
			 * Lastname is the JWT claim for user last name.
			 */
			lastname?: pulumi.Input<string>;
			/**
			 * UserID is the JWT claim for user ID mapping.
			 */
			userId?: pulumi.Input<string>;
		}

		/**
		 * OIDC configures the OIDC authentication.
		 */
		export interface APIPortalAuthSpecOidcPatch {
			claims?: pulumi.Input<inputs.hub.v1alpha1.APIPortalAuthSpecOidcClaimsPatch>;
			/**
			 * IssuerURL is the OIDC provider issuer URL.
			 */
			issuerUrl?: pulumi.Input<string>;
			/**
			 * Scopes is a list of OAuth2 scopes.
			 */
			scopes?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * SecretName is the name of the Kubernetes Secret containing clientId and clientSecret keys.
			 */
			secretName?: pulumi.Input<string>;
			/**
			 * SyncedAttributes is a list of additional attributes to sync from the OIDC provider.
			 * Each attribute must correspond to a configured claim field.
			 */
			syncedAttributes?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * The desired behavior of this APIPortalAuth.
		 */
		export interface APIPortalAuthSpecPatch {
			oidc?: pulumi.Input<inputs.hub.v1alpha1.APIPortalAuthSpecOidcPatch>;
		}

		/**
		 * The current status of this APIPortalAuth.
		 */
		export interface APIPortalAuthStatus {
			/**
			 * Hash is a hash representing the APIPortalAuth.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * The desired behavior of this APIPortal.
		 */
		export interface APIPortalSpec {
			auth?: pulumi.Input<inputs.hub.v1alpha1.APIPortalSpecAuth>;
			/**
			 * Description of the APIPortal.
			 */
			description?: pulumi.Input<string>;
			/**
			 * Title is the public facing name of the APIPortal.
			 */
			title?: pulumi.Input<string>;
			/**
			 * TrustedURLs are the urls that are trusted by the OAuth 2.0 authorization server.
			 */
			trustedUrls?: pulumi.Input<pulumi.Input<string>[]>;
			ui?: pulumi.Input<inputs.hub.v1alpha1.APIPortalSpecUi>;
		}

		/**
		 * Auth references the APIPortalAuth resource for authentication configuration.
		 */
		export interface APIPortalSpecAuth {
			/**
			 * Name is the name of the APIPortalAuth resource.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * Auth references the APIPortalAuth resource for authentication configuration.
		 */
		export interface APIPortalSpecAuthPatch {
			/**
			 * Name is the name of the APIPortalAuth resource.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * The desired behavior of this APIPortal.
		 */
		export interface APIPortalSpecPatch {
			auth?: pulumi.Input<inputs.hub.v1alpha1.APIPortalSpecAuthPatch>;
			/**
			 * Description of the APIPortal.
			 */
			description?: pulumi.Input<string>;
			/**
			 * Title is the public facing name of the APIPortal.
			 */
			title?: pulumi.Input<string>;
			/**
			 * TrustedURLs are the urls that are trusted by the OAuth 2.0 authorization server.
			 */
			trustedUrls?: pulumi.Input<pulumi.Input<string>[]>;
			ui?: pulumi.Input<inputs.hub.v1alpha1.APIPortalSpecUiPatch>;
		}

		/**
		 * UI holds the UI customization options.
		 */
		export interface APIPortalSpecUi {
			/**
			 * LogoURL is the public URL of the logo.
			 */
			logoUrl?: pulumi.Input<string>;
		}

		/**
		 * UI holds the UI customization options.
		 */
		export interface APIPortalSpecUiPatch {
			/**
			 * LogoURL is the public URL of the logo.
			 */
			logoUrl?: pulumi.Input<string>;
		}

		/**
		 * The current status of this APIPortal.
		 */
		export interface APIPortalStatus {
			/**
			 * Hash is a hash representing the APIPortal.
			 */
			hash?: pulumi.Input<string>;
			oidc?: pulumi.Input<inputs.hub.v1alpha1.APIPortalStatusOidc>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * OIDC is the OIDC configuration for accessing the exposed APIPortal WebUI.
		 */
		export interface APIPortalStatusOidc {
			/**
			 * ClientID is the OIDC ClientID for accessing the exposed APIPortal WebUI.
			 */
			clientId?: pulumi.Input<string>;
			/**
			 * CompanyClaim is the name of the JWT claim containing the user company.
			 */
			companyClaim?: pulumi.Input<string>;
			/**
			 * EmailClaim is the name of the JWT claim containing the user email.
			 */
			emailClaim?: pulumi.Input<string>;
			/**
			 * FirstnameClaim is the name of the JWT claim containing the user firstname.
			 */
			firstnameClaim?: pulumi.Input<string>;
			/**
			 * Generic indicates whether or not the APIPortal authentication relies on Generic OIDC.
			 */
			generic?: pulumi.Input<boolean>;
			/**
			 * GroupsClaim is the name of the JWT claim containing the user groups.
			 */
			groupsClaim?: pulumi.Input<string>;
			/**
			 * Issuer is the OIDC issuer for accessing the exposed APIPortal WebUI.
			 */
			issuer?: pulumi.Input<string>;
			/**
			 * LastnameClaim is the name of the JWT claim containing the user lastname.
			 */
			lastnameClaim?: pulumi.Input<string>;
			/**
			 * Scopes is the OIDC scopes for getting user attributes during the authentication to the exposed APIPortal WebUI.
			 */
			scopes?: pulumi.Input<string>;
			/**
			 * SecretName is the name of the secret containing the OIDC ClientSecret for accessing the exposed APIPortal WebUI.
			 */
			secretName?: pulumi.Input<string>;
			/**
			 * SyncedAttributes configure the user attributes to sync.
			 */
			syncedAttributes?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * UserIDClaim is the name of the JWT claim containing the user ID.
			 */
			userIdClaim?: pulumi.Input<string>;
		}

		/**
		 * APIRateLimit defines how group of consumers are rate limited on a set of APIs.
		 */
		export interface APIRateLimit {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APIRateLimit">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APIRateLimitSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIRateLimitStatus>;
		}

		/**
		 * The desired behavior of this APIRateLimit.
		 */
		export interface APIRateLimitSpec {
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.APIRateLimitSpecApiSelector>;
			/**
			 * APIs defines a set of APIs that will be rate limited.
			 * Multiple APIRateLimits can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIRateLimitSpecApis>[]
			>;
			/**
			 * Everyone indicates that all users will, by default, be rate limited with this configuration.
			 * If an APIRateLimit explicitly target a group, the default rate limit will be ignored.
			 */
			everyone?: pulumi.Input<boolean>;
			/**
			 * Groups are the consumer groups that will be rate limited.
			 * Multiple APIRateLimits can target the same set of consumer groups, the most restrictive one applies.
			 * When a consumer belongs to multiple groups, the least restrictive APIRateLimit applies.
			 */
			groups?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Limit is the maximum number of token in the bucket.
			 */
			limit?: pulumi.Input<number>;
			/**
			 * Period is the unit of time for the Limit.
			 */
			period?: pulumi.Input<string>;
			/**
			 * Strategy defines how the bucket state will be synchronized between the different Traefik Hub instances.
			 * It can be, either "local" or "distributed".
			 */
			strategy?: pulumi.Input<string>;
		}

		/**
		 * APISelector selects the APIs that will be rate limited.
		 * Multiple APIRateLimits can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface APIRateLimitSpecApiSelector {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIRateLimitSpecApiSelectorMatchExpressions>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface APIRateLimitSpecApiSelectorMatchExpressions {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface APIRateLimitSpecApiSelectorMatchExpressionsPatch {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * APISelector selects the APIs that will be rate limited.
		 * Multiple APIRateLimits can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface APIRateLimitSpecApiSelectorPatch {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIRateLimitSpecApiSelectorMatchExpressionsPatch>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface APIRateLimitSpecApis {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface APIRateLimitSpecApisPatch {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * The desired behavior of this APIRateLimit.
		 */
		export interface APIRateLimitSpecPatch {
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.APIRateLimitSpecApiSelectorPatch>;
			/**
			 * APIs defines a set of APIs that will be rate limited.
			 * Multiple APIRateLimits can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIRateLimitSpecApisPatch>[]
			>;
			/**
			 * Everyone indicates that all users will, by default, be rate limited with this configuration.
			 * If an APIRateLimit explicitly target a group, the default rate limit will be ignored.
			 */
			everyone?: pulumi.Input<boolean>;
			/**
			 * Groups are the consumer groups that will be rate limited.
			 * Multiple APIRateLimits can target the same set of consumer groups, the most restrictive one applies.
			 * When a consumer belongs to multiple groups, the least restrictive APIRateLimit applies.
			 */
			groups?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Limit is the maximum number of token in the bucket.
			 */
			limit?: pulumi.Input<number>;
			/**
			 * Period is the unit of time for the Limit.
			 */
			period?: pulumi.Input<string>;
			/**
			 * Strategy defines how the bucket state will be synchronized between the different Traefik Hub instances.
			 * It can be, either "local" or "distributed".
			 */
			strategy?: pulumi.Input<string>;
		}

		/**
		 * The current status of this APIRateLimit.
		 */
		export interface APIRateLimitStatus {
			/**
			 * Hash is a hash representing the APIRateLimit.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * APISpec describes the API.
		 */
		export interface APISpec {
			cors?: pulumi.Input<inputs.hub.v1alpha1.APISpecCors>;
			/**
			 * Description explains what the API does.
			 */
			description?: pulumi.Input<string>;
			openApiSpec?: pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpec>;
			/**
			 * Title is the human-readable name of the API that will be used on the portal.
			 */
			title?: pulumi.Input<string>;
			/**
			 * Versions are the different APIVersions available.
			 */
			versions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecVersions>[]
			>;
		}

		/**
		 * Cors defines the Cross-Origin Resource Sharing configuration.
		 */
		export interface APISpecCors {
			/**
			 * AddVaryHeader defines whether the Vary header is automatically added/updated when the AllowOriginsList is set.
			 */
			addVaryHeader?: pulumi.Input<boolean>;
			/**
			 * AllowCredentials defines whether the request can include user credentials.
			 */
			allowCredentials?: pulumi.Input<boolean>;
			/**
			 * AllowHeadersList defines the Access-Control-Request-Headers values sent in preflight response.
			 */
			allowHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowMethodsList defines the Access-Control-Request-Method values sent in preflight response.
			 */
			allowMethodsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
			 */
			allowOriginListRegex?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginsList is a list of allowable origins. Can also be a wildcard origin "*".
			 */
			allowOriginsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ExposeHeadersList defines the Access-Control-Expose-Headers values sent in preflight response.
			 */
			exposeHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MaxAge defines the time that a preflight request may be cached.
			 */
			maxAge?: pulumi.Input<number>;
		}

		/**
		 * Cors defines the Cross-Origin Resource Sharing configuration.
		 */
		export interface APISpecCorsPatch {
			/**
			 * AddVaryHeader defines whether the Vary header is automatically added/updated when the AllowOriginsList is set.
			 */
			addVaryHeader?: pulumi.Input<boolean>;
			/**
			 * AllowCredentials defines whether the request can include user credentials.
			 */
			allowCredentials?: pulumi.Input<boolean>;
			/**
			 * AllowHeadersList defines the Access-Control-Request-Headers values sent in preflight response.
			 */
			allowHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowMethodsList defines the Access-Control-Request-Method values sent in preflight response.
			 */
			allowMethodsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
			 */
			allowOriginListRegex?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginsList is a list of allowable origins. Can also be a wildcard origin "*".
			 */
			allowOriginsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ExposeHeadersList defines the Access-Control-Expose-Headers values sent in preflight response.
			 */
			exposeHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MaxAge defines the time that a preflight request may be cached.
			 */
			maxAge?: pulumi.Input<number>;
		}

		/**
		 * OpenAPISpec defines the API contract as an OpenAPI specification.
		 */
		export interface APISpecOpenApiSpec {
			/**
			 * OperationSets defines the sets of operations to be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
			 */
			operationSets?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOperationSets>[]
			>;
			override?: pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOverride>;
			/**
			 * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
			 * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
			 * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
			 * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			path?: pulumi.Input<string>;
			/**
			 * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
			 * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			url?: pulumi.Input<string>;
			/**
			 * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
			 * This option overrides the default behavior configured in the static configuration.
			 */
			validateRequestMethodAndPath?: pulumi.Input<boolean>;
		}

		/**
		 * OperationSet gives a name to a set of matching OpenAPI operations.
		 * This set of operations can then be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
		 */
		export interface APISpecOpenApiSpecOperationSets {
			/**
			 * Matchers defines a list of alternative rules for matching OpenAPI operations.
			 */
			matchers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOperationSetsMatchers>[]
			>;
			/**
			 * Name is the name of the OperationSet to reference in APICatalogItems or ManagedSubscriptions.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * OperationMatcher defines criteria for matching an OpenAPI operation.
		 */
		export interface APISpecOpenApiSpecOperationSetsMatchers {
			/**
			 * Methods specifies the HTTP methods to be included for selection.
			 */
			methods?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Path specifies the exact path of the operations to select.
			 */
			path?: pulumi.Input<string>;
			/**
			 * PathPrefix specifies the path prefix of the operations to select.
			 */
			pathPrefix?: pulumi.Input<string>;
			/**
			 * PathRegex specifies a regular expression pattern for matching operations based on their paths.
			 */
			pathRegex?: pulumi.Input<string>;
		}

		/**
		 * OperationMatcher defines criteria for matching an OpenAPI operation.
		 */
		export interface APISpecOpenApiSpecOperationSetsMatchersPatch {
			/**
			 * Methods specifies the HTTP methods to be included for selection.
			 */
			methods?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Path specifies the exact path of the operations to select.
			 */
			path?: pulumi.Input<string>;
			/**
			 * PathPrefix specifies the path prefix of the operations to select.
			 */
			pathPrefix?: pulumi.Input<string>;
			/**
			 * PathRegex specifies a regular expression pattern for matching operations based on their paths.
			 */
			pathRegex?: pulumi.Input<string>;
		}

		/**
		 * OperationSet gives a name to a set of matching OpenAPI operations.
		 * This set of operations can then be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
		 */
		export interface APISpecOpenApiSpecOperationSetsPatch {
			/**
			 * Matchers defines a list of alternative rules for matching OpenAPI operations.
			 */
			matchers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOperationSetsMatchersPatch>[]
			>;
			/**
			 * Name is the name of the OperationSet to reference in APICatalogItems or ManagedSubscriptions.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * Override holds data used to override OpenAPI specification.
		 */
		export interface APISpecOpenApiSpecOverride {
			servers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOverrideServers>[]
			>;
		}

		/**
		 * Override holds data used to override OpenAPI specification.
		 */
		export interface APISpecOpenApiSpecOverridePatch {
			servers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOverrideServersPatch>[]
			>;
		}

		export interface APISpecOpenApiSpecOverrideServers {
			url?: pulumi.Input<string>;
		}

		export interface APISpecOpenApiSpecOverrideServersPatch {
			url?: pulumi.Input<string>;
		}

		/**
		 * OpenAPISpec defines the API contract as an OpenAPI specification.
		 */
		export interface APISpecOpenApiSpecPatch {
			/**
			 * OperationSets defines the sets of operations to be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
			 */
			operationSets?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOperationSetsPatch>[]
			>;
			override?: pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecOverridePatch>;
			/**
			 * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
			 * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
			 * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
			 * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			path?: pulumi.Input<string>;
			/**
			 * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
			 * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			url?: pulumi.Input<string>;
			/**
			 * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
			 * This option overrides the default behavior configured in the static configuration.
			 */
			validateRequestMethodAndPath?: pulumi.Input<boolean>;
		}

		/**
		 * APISpec describes the API.
		 */
		export interface APISpecPatch {
			cors?: pulumi.Input<inputs.hub.v1alpha1.APISpecCorsPatch>;
			/**
			 * Description explains what the API does.
			 */
			description?: pulumi.Input<string>;
			openApiSpec?: pulumi.Input<inputs.hub.v1alpha1.APISpecOpenApiSpecPatch>;
			/**
			 * Title is the human-readable name of the API that will be used on the portal.
			 */
			title?: pulumi.Input<string>;
			/**
			 * Versions are the different APIVersions available.
			 */
			versions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APISpecVersionsPatch>[]
			>;
		}

		/**
		 * APIVersionRef references an APIVersion.
		 */
		export interface APISpecVersions {
			/**
			 * Name of the APIVersion.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIVersionRef references an APIVersion.
		 */
		export interface APISpecVersionsPatch {
			/**
			 * Name of the APIVersion.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * The current status of this API.
		 */
		export interface APIStatus {
			/**
			 * Hash is a hash representing the API.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * APIVersion defines a version of an API.
		 */
		export interface APIVersion {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"APIVersion">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.APIVersionSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.APIVersionStatus>;
		}

		/**
		 * The desired behavior of this APIVersion.
		 */
		export interface APIVersionSpec {
			cors?: pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecCors>;
			/**
			 * Description explains what the APIVersion does.
			 */
			description?: pulumi.Input<string>;
			openApiSpec?: pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpec>;
			/**
			 * Release is the version number of the API.
			 * This value must follow the SemVer format: https://semver.org/
			 */
			release?: pulumi.Input<string>;
			/**
			 * Title is the public facing name of the APIVersion.
			 */
			title?: pulumi.Input<string>;
		}

		/**
		 * Cors defines the Cross-Origin Resource Sharing configuration.
		 */
		export interface APIVersionSpecCors {
			/**
			 * AddVaryHeader defines whether the Vary header is automatically added/updated when the AllowOriginsList is set.
			 */
			addVaryHeader?: pulumi.Input<boolean>;
			/**
			 * AllowCredentials defines whether the request can include user credentials.
			 */
			allowCredentials?: pulumi.Input<boolean>;
			/**
			 * AllowHeadersList defines the Access-Control-Request-Headers values sent in preflight response.
			 */
			allowHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowMethodsList defines the Access-Control-Request-Method values sent in preflight response.
			 */
			allowMethodsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
			 */
			allowOriginListRegex?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginsList is a list of allowable origins. Can also be a wildcard origin "*".
			 */
			allowOriginsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ExposeHeadersList defines the Access-Control-Expose-Headers values sent in preflight response.
			 */
			exposeHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MaxAge defines the time that a preflight request may be cached.
			 */
			maxAge?: pulumi.Input<number>;
		}

		/**
		 * Cors defines the Cross-Origin Resource Sharing configuration.
		 */
		export interface APIVersionSpecCorsPatch {
			/**
			 * AddVaryHeader defines whether the Vary header is automatically added/updated when the AllowOriginsList is set.
			 */
			addVaryHeader?: pulumi.Input<boolean>;
			/**
			 * AllowCredentials defines whether the request can include user credentials.
			 */
			allowCredentials?: pulumi.Input<boolean>;
			/**
			 * AllowHeadersList defines the Access-Control-Request-Headers values sent in preflight response.
			 */
			allowHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowMethodsList defines the Access-Control-Request-Method values sent in preflight response.
			 */
			allowMethodsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
			 */
			allowOriginListRegex?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AllowOriginsList is a list of allowable origins. Can also be a wildcard origin "*".
			 */
			allowOriginsList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ExposeHeadersList defines the Access-Control-Expose-Headers values sent in preflight response.
			 */
			exposeHeadersList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MaxAge defines the time that a preflight request may be cached.
			 */
			maxAge?: pulumi.Input<number>;
		}

		/**
		 * OpenAPISpec defines the API contract as an OpenAPI specification.
		 */
		export interface APIVersionSpecOpenApiSpec {
			/**
			 * OperationSets defines the sets of operations to be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
			 */
			operationSets?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOperationSets>[]
			>;
			override?: pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOverride>;
			/**
			 * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
			 * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
			 * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
			 * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			path?: pulumi.Input<string>;
			/**
			 * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
			 * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			url?: pulumi.Input<string>;
			/**
			 * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
			 * This option overrides the default behavior configured in the static configuration.
			 */
			validateRequestMethodAndPath?: pulumi.Input<boolean>;
		}

		/**
		 * OperationSet gives a name to a set of matching OpenAPI operations.
		 * This set of operations can then be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
		 */
		export interface APIVersionSpecOpenApiSpecOperationSets {
			/**
			 * Matchers defines a list of alternative rules for matching OpenAPI operations.
			 */
			matchers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOperationSetsMatchers>[]
			>;
			/**
			 * Name is the name of the OperationSet to reference in APICatalogItems or ManagedSubscriptions.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * OperationMatcher defines criteria for matching an OpenAPI operation.
		 */
		export interface APIVersionSpecOpenApiSpecOperationSetsMatchers {
			/**
			 * Methods specifies the HTTP methods to be included for selection.
			 */
			methods?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Path specifies the exact path of the operations to select.
			 */
			path?: pulumi.Input<string>;
			/**
			 * PathPrefix specifies the path prefix of the operations to select.
			 */
			pathPrefix?: pulumi.Input<string>;
			/**
			 * PathRegex specifies a regular expression pattern for matching operations based on their paths.
			 */
			pathRegex?: pulumi.Input<string>;
		}

		/**
		 * OperationMatcher defines criteria for matching an OpenAPI operation.
		 */
		export interface APIVersionSpecOpenApiSpecOperationSetsMatchersPatch {
			/**
			 * Methods specifies the HTTP methods to be included for selection.
			 */
			methods?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Path specifies the exact path of the operations to select.
			 */
			path?: pulumi.Input<string>;
			/**
			 * PathPrefix specifies the path prefix of the operations to select.
			 */
			pathPrefix?: pulumi.Input<string>;
			/**
			 * PathRegex specifies a regular expression pattern for matching operations based on their paths.
			 */
			pathRegex?: pulumi.Input<string>;
		}

		/**
		 * OperationSet gives a name to a set of matching OpenAPI operations.
		 * This set of operations can then be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
		 */
		export interface APIVersionSpecOpenApiSpecOperationSetsPatch {
			/**
			 * Matchers defines a list of alternative rules for matching OpenAPI operations.
			 */
			matchers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOperationSetsMatchersPatch>[]
			>;
			/**
			 * Name is the name of the OperationSet to reference in APICatalogItems or ManagedSubscriptions.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * Override holds data used to override OpenAPI specification.
		 */
		export interface APIVersionSpecOpenApiSpecOverride {
			servers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOverrideServers>[]
			>;
		}

		/**
		 * Override holds data used to override OpenAPI specification.
		 */
		export interface APIVersionSpecOpenApiSpecOverridePatch {
			servers?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOverrideServersPatch>[]
			>;
		}

		export interface APIVersionSpecOpenApiSpecOverrideServers {
			url?: pulumi.Input<string>;
		}

		export interface APIVersionSpecOpenApiSpecOverrideServersPatch {
			url?: pulumi.Input<string>;
		}

		/**
		 * OpenAPISpec defines the API contract as an OpenAPI specification.
		 */
		export interface APIVersionSpecOpenApiSpecPatch {
			/**
			 * OperationSets defines the sets of operations to be referenced for granular filtering in APICatalogItems or ManagedSubscriptions.
			 */
			operationSets?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOperationSetsPatch>[]
			>;
			override?: pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecOverridePatch>;
			/**
			 * Path specifies the endpoint path within the Kubernetes Service where the OpenAPI specification can be obtained.
			 * The Service queried is determined by the associated Ingress, IngressRoute, or HTTPRoute resource to which the API is attached.
			 * It's important to note that this option is incompatible if the Ingress or IngressRoute specifies multiple backend services.
			 * The Path must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			path?: pulumi.Input<string>;
			/**
			 * URL is a Traefik Hub agent accessible URL for obtaining the OpenAPI specification.
			 * The URL must be accessible via a GET request method and should serve a YAML or JSON document containing the OpenAPI specification.
			 */
			url?: pulumi.Input<string>;
			/**
			 * ValidateRequestMethodAndPath validates that the path and method matches an operation defined in the OpenAPI specification.
			 * This option overrides the default behavior configured in the static configuration.
			 */
			validateRequestMethodAndPath?: pulumi.Input<boolean>;
		}

		/**
		 * The desired behavior of this APIVersion.
		 */
		export interface APIVersionSpecPatch {
			cors?: pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecCorsPatch>;
			/**
			 * Description explains what the APIVersion does.
			 */
			description?: pulumi.Input<string>;
			openApiSpec?: pulumi.Input<inputs.hub.v1alpha1.APIVersionSpecOpenApiSpecPatch>;
			/**
			 * Release is the version number of the API.
			 * This value must follow the SemVer format: https://semver.org/
			 */
			release?: pulumi.Input<string>;
			/**
			 * Title is the public facing name of the APIVersion.
			 */
			title?: pulumi.Input<string>;
		}

		/**
		 * The current status of this APIVersion.
		 */
		export interface APIVersionStatus {
			/**
			 * Hash is a hash representing the APIVersion.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * ManagedApplication represents a managed application.
		 */
		export interface ManagedApplication {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"ManagedApplication">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.ManagedApplicationSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.ManagedApplicationStatus>;
		}

		/**
		 * ManagedApplicationSpec describes the ManagedApplication.
		 */
		export interface ManagedApplicationSpec {
			/**
			 * APIKeys references the API keys used to authenticate the application when calling APIs.
			 */
			apiKeys?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedApplicationSpecApiKeys>[]
			>;
			/**
			 * AppID is the identifier of the ManagedApplication.
			 * It should be unique.
			 */
			appId?: pulumi.Input<string>;
			/**
			 * Notes contains notes about application.
			 */
			notes?: pulumi.Input<string>;
			/**
			 * Owner represents the owner of the ManagedApplication.
			 * It should be:
			 * - `sub` when using OIDC
			 * - `externalID` when using external IDP
			 */
			owner?: pulumi.Input<string>;
		}

		export interface ManagedApplicationSpecApiKeys {
			/**
			 * SecretName references the name of the secret containing the API key.
			 */
			secretName?: pulumi.Input<string>;
			suspended?: pulumi.Input<boolean>;
			title?: pulumi.Input<string>;
			/**
			 * Value is the API key value.
			 */
			value?: pulumi.Input<string>;
		}

		export interface ManagedApplicationSpecApiKeysPatch {
			/**
			 * SecretName references the name of the secret containing the API key.
			 */
			secretName?: pulumi.Input<string>;
			suspended?: pulumi.Input<boolean>;
			title?: pulumi.Input<string>;
			/**
			 * Value is the API key value.
			 */
			value?: pulumi.Input<string>;
		}

		/**
		 * ManagedApplicationSpec describes the ManagedApplication.
		 */
		export interface ManagedApplicationSpecPatch {
			/**
			 * APIKeys references the API keys used to authenticate the application when calling APIs.
			 */
			apiKeys?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedApplicationSpecApiKeysPatch>[]
			>;
			/**
			 * AppID is the identifier of the ManagedApplication.
			 * It should be unique.
			 */
			appId?: pulumi.Input<string>;
			/**
			 * Notes contains notes about application.
			 */
			notes?: pulumi.Input<string>;
			/**
			 * Owner represents the owner of the ManagedApplication.
			 * It should be:
			 * - `sub` when using OIDC
			 * - `externalID` when using external IDP
			 */
			owner?: pulumi.Input<string>;
		}

		/**
		 * The current status of this ManagedApplication.
		 */
		export interface ManagedApplicationStatus {
			apiKeyVersions?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hash is a hash representing the ManagedApplication.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}

		/**
		 * ManagedSubscription defines a Subscription managed by the API manager as the result of a pre-negotiation with its
		 * API consumers. This subscription grant consuming access to a set of APIs to a set of Applications.
		 */
		export interface ManagedSubscription {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"hub.traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"ManagedSubscription">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpec>;
			status?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionStatus>;
		}

		/**
		 * The desired behavior of this ManagedSubscription.
		 */
		export interface ManagedSubscriptionSpec {
			/**
			 * APIBundles defines a set of APIBundle that will be accessible.
			 * Multiple ManagedSubscriptions can select the same APIBundles.
			 */
			apiBundles?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiBundles>[]
			>;
			apiPlan?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiPlan>;
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiSelector>;
			/**
			 * APIs defines a set of APIs that will be accessible.
			 * Multiple ManagedSubscriptions can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApis>[]
			>;
			/**
			 * Applications references the Applications that will gain access to the specified APIs.
			 * Multiple ManagedSubscriptions can select the same AppID.
			 * Deprecated: Use ManagedApplications instead.
			 */
			applications?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApplications>[]
			>;
			/**
			 * Claims specifies an expression that validate claims in order to authorize the request.
			 */
			claims?: pulumi.Input<string>;
			/**
			 * ManagedApplications references the ManagedApplications that will gain access to the specified APIs.
			 * Multiple ManagedSubscriptions can select the same ManagedApplication.
			 */
			managedApplications?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecManagedApplications>[]
			>;
			operationFilter?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecOperationFilter>;
			/**
			 * Weight specifies the evaluation order of the APIPlan.
			 * When multiple ManagedSubscriptions targets the same API and Application with different APIPlan,
			 * the APIPlan with the highest weight will be enforced. If weights are equal, alphabetical order is used.
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * APIBundleReference references an APIBundle.
		 */
		export interface ManagedSubscriptionSpecApiBundles {
			/**
			 * Name of the APIBundle.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIBundleReference references an APIBundle.
		 */
		export interface ManagedSubscriptionSpecApiBundlesPatch {
			/**
			 * Name of the APIBundle.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIPlan defines which APIPlan will be used.
		 */
		export interface ManagedSubscriptionSpecApiPlan {
			/**
			 * Name of the APIPlan.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIPlan defines which APIPlan will be used.
		 */
		export interface ManagedSubscriptionSpecApiPlanPatch {
			/**
			 * Name of the APIPlan.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APISelector selects the APIs that will be accessible.
		 * Multiple ManagedSubscriptions can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface ManagedSubscriptionSpecApiSelector {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiSelectorMatchExpressions>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface ManagedSubscriptionSpecApiSelectorMatchExpressions {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * A label selector requirement is a selector that contains values, a key, and an operator that
		 * relates the key and values.
		 */
		export interface ManagedSubscriptionSpecApiSelectorMatchExpressionsPatch {
			/**
			 * key is the label key that the selector applies to.
			 */
			key?: pulumi.Input<string>;
			/**
			 * operator represents a key's relationship to a set of values.
			 * Valid operators are In, NotIn, Exists and DoesNotExist.
			 */
			operator?: pulumi.Input<string>;
			/**
			 * values is an array of string values. If the operator is In or NotIn,
			 * the values array must be non-empty. If the operator is Exists or DoesNotExist,
			 * the values array must be empty. This array is replaced during a strategic
			 * merge patch.
			 */
			values?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * APISelector selects the APIs that will be accessible.
		 * Multiple ManagedSubscriptions can select the same set of APIs.
		 * This field is optional and follows standard label selector semantics.
		 * An empty APISelector matches any API.
		 */
		export interface ManagedSubscriptionSpecApiSelectorPatch {
			/**
			 * matchExpressions is a list of label selector requirements. The requirements are ANDed.
			 */
			matchExpressions?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiSelectorMatchExpressionsPatch>[]
			>;
			/**
			 * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
			 * map is equivalent to an element of matchExpressions, whose key field is "key", the
			 * operator is "In", and the values array contains only "value". The requirements are ANDed.
			 */
			matchLabels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface ManagedSubscriptionSpecApis {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * APIReference references an API.
		 */
		export interface ManagedSubscriptionSpecApisPatch {
			/**
			 * Name of the API.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * ApplicationReference references an Application.
		 */
		export interface ManagedSubscriptionSpecApplications {
			/**
			 * AppID is the public identifier of the application.
			 * In the case of OIDC, it corresponds to the clientId.
			 */
			appId?: pulumi.Input<string>;
		}

		/**
		 * ApplicationReference references an Application.
		 */
		export interface ManagedSubscriptionSpecApplicationsPatch {
			/**
			 * AppID is the public identifier of the application.
			 * In the case of OIDC, it corresponds to the clientId.
			 */
			appId?: pulumi.Input<string>;
		}

		/**
		 * ManagedApplicationReference references a ManagedApplication.
		 */
		export interface ManagedSubscriptionSpecManagedApplications {
			/**
			 * Name is the name of the ManagedApplication.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * ManagedApplicationReference references a ManagedApplication.
		 */
		export interface ManagedSubscriptionSpecManagedApplicationsPatch {
			/**
			 * Name is the name of the ManagedApplication.
			 */
			name?: pulumi.Input<string>;
		}

		/**
		 * OperationFilter specifies the allowed operations on APIs and APIVersions.
		 * If not set, all operations are available.
		 * An empty OperationFilter prohibits all operations.
		 */
		export interface ManagedSubscriptionSpecOperationFilter {
			/**
			 * Include defines the names of OperationSets that will be accessible.
			 */
			include?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * OperationFilter specifies the allowed operations on APIs and APIVersions.
		 * If not set, all operations are available.
		 * An empty OperationFilter prohibits all operations.
		 */
		export interface ManagedSubscriptionSpecOperationFilterPatch {
			/**
			 * Include defines the names of OperationSets that will be accessible.
			 */
			include?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * The desired behavior of this ManagedSubscription.
		 */
		export interface ManagedSubscriptionSpecPatch {
			/**
			 * APIBundles defines a set of APIBundle that will be accessible.
			 * Multiple ManagedSubscriptions can select the same APIBundles.
			 */
			apiBundles?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiBundlesPatch>[]
			>;
			apiPlan?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiPlanPatch>;
			apiSelector?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApiSelectorPatch>;
			/**
			 * APIs defines a set of APIs that will be accessible.
			 * Multiple ManagedSubscriptions can select the same APIs.
			 * When combined with APISelector, this set of APIs is appended to the matching APIs.
			 */
			apis?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApisPatch>[]
			>;
			/**
			 * Applications references the Applications that will gain access to the specified APIs.
			 * Multiple ManagedSubscriptions can select the same AppID.
			 * Deprecated: Use ManagedApplications instead.
			 */
			applications?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecApplicationsPatch>[]
			>;
			/**
			 * Claims specifies an expression that validate claims in order to authorize the request.
			 */
			claims?: pulumi.Input<string>;
			/**
			 * ManagedApplications references the ManagedApplications that will gain access to the specified APIs.
			 * Multiple ManagedSubscriptions can select the same ManagedApplication.
			 */
			managedApplications?: pulumi.Input<
				pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecManagedApplicationsPatch>[]
			>;
			operationFilter?: pulumi.Input<inputs.hub.v1alpha1.ManagedSubscriptionSpecOperationFilterPatch>;
			/**
			 * Weight specifies the evaluation order of the APIPlan.
			 * When multiple ManagedSubscriptions targets the same API and Application with different APIPlan,
			 * the APIPlan with the highest weight will be enforced. If weights are equal, alphabetical order is used.
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * The current status of this ManagedSubscription.
		 */
		export interface ManagedSubscriptionStatus {
			/**
			 * Hash is a hash representing the ManagedSubscription.
			 */
			hash?: pulumi.Input<string>;
			syncedAt?: pulumi.Input<string>;
			version?: pulumi.Input<string>;
		}
	}
}

export namespace meta {
	export namespace v1 {
		/**
		 * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
		 */
		export interface ListMeta {
			/**
			 * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
			 */
			continue?: pulumi.Input<string>;
			/**
			 * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
			 */
			remainingItemCount?: pulumi.Input<number>;
			/**
			 * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
			 */
			resourceVersion?: pulumi.Input<string>;
			/**
			 * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
			 */
			selfLink?: pulumi.Input<string>;
		}

		/**
		 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
		 */
		export interface ManagedFieldsEntry {
			/**
			 * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
			 */
			apiVersion?: pulumi.Input<string>;
			/**
			 * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
			 */
			fieldsType?: pulumi.Input<string>;
			/**
			 * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
			 */
			fieldsV1?: any;
			/**
			 * Manager is an identifier of the workflow managing these fields.
			 */
			manager?: pulumi.Input<string>;
			/**
			 * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
			 */
			operation?: pulumi.Input<string>;
			/**
			 * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
			 */
			subresource?: pulumi.Input<string>;
			/**
			 * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
			 */
			time?: pulumi.Input<string>;
		}

		/**
		 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
		 */
		export interface ManagedFieldsEntryPatch {
			/**
			 * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
			 */
			apiVersion?: pulumi.Input<string>;
			/**
			 * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
			 */
			fieldsType?: pulumi.Input<string>;
			/**
			 * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
			 */
			fieldsV1?: any;
			/**
			 * Manager is an identifier of the workflow managing these fields.
			 */
			manager?: pulumi.Input<string>;
			/**
			 * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
			 */
			operation?: pulumi.Input<string>;
			/**
			 * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
			 */
			subresource?: pulumi.Input<string>;
			/**
			 * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
			 */
			time?: pulumi.Input<string>;
		}

		/**
		 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
		 */
		export interface ObjectMeta {
			/**
			 * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
			 */
			annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
			 *
			 * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			creationTimestamp?: pulumi.Input<string>;
			/**
			 * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
			 */
			deletionGracePeriodSeconds?: pulumi.Input<number>;
			/**
			 * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
			 *
			 * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			deletionTimestamp?: pulumi.Input<string>;
			/**
			 * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
			 */
			finalizers?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
			 *
			 * If this field is specified and the generated name exists, the server will return a 409.
			 *
			 * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
			 */
			generateName?: pulumi.Input<string>;
			/**
			 * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
			 */
			generation?: pulumi.Input<number>;
			/**
			 * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
			 */
			labels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
			 */
			managedFields?: pulumi.Input<
				pulumi.Input<inputs.meta.v1.ManagedFieldsEntry>[]
			>;
			/**
			 * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
			 *
			 * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
			 */
			ownerReferences?: pulumi.Input<
				pulumi.Input<inputs.meta.v1.OwnerReference>[]
			>;
			/**
			 * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
			 *
			 * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
			 */
			resourceVersion?: pulumi.Input<string>;
			/**
			 * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
			 */
			selfLink?: pulumi.Input<string>;
			/**
			 * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
			 *
			 * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
			 */
			uid?: pulumi.Input<string>;
		}

		/**
		 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
		 */
		export interface ObjectMetaPatch {
			/**
			 * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
			 */
			annotations?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
			 *
			 * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			creationTimestamp?: pulumi.Input<string>;
			/**
			 * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
			 */
			deletionGracePeriodSeconds?: pulumi.Input<number>;
			/**
			 * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
			 *
			 * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			deletionTimestamp?: pulumi.Input<string>;
			/**
			 * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
			 */
			finalizers?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
			 *
			 * If this field is specified and the generated name exists, the server will return a 409.
			 *
			 * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
			 */
			generateName?: pulumi.Input<string>;
			/**
			 * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
			 */
			generation?: pulumi.Input<number>;
			/**
			 * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
			 */
			labels?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
			 */
			managedFields?: pulumi.Input<
				pulumi.Input<inputs.meta.v1.ManagedFieldsEntryPatch>[]
			>;
			/**
			 * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
			 *
			 * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
			 */
			ownerReferences?: pulumi.Input<
				pulumi.Input<inputs.meta.v1.OwnerReferencePatch>[]
			>;
			/**
			 * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
			 *
			 * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
			 */
			resourceVersion?: pulumi.Input<string>;
			/**
			 * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
			 */
			selfLink?: pulumi.Input<string>;
			/**
			 * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
			 *
			 * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
			 */
			uid?: pulumi.Input<string>;
		}

		/**
		 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
		 */
		export interface OwnerReference {
			/**
			 * API version of the referent.
			 */
			apiVersion: pulumi.Input<string>;
			/**
			 * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
			 */
			blockOwnerDeletion?: pulumi.Input<boolean>;
			/**
			 * If true, this reference points to the managing controller.
			 */
			controller?: pulumi.Input<boolean>;
			/**
			 * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind: pulumi.Input<string>;
			/**
			 * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
			 */
			name: pulumi.Input<string>;
			/**
			 * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
			 */
			uid: pulumi.Input<string>;
		}

		/**
		 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
		 */
		export interface OwnerReferencePatch {
			/**
			 * API version of the referent.
			 */
			apiVersion?: pulumi.Input<string>;
			/**
			 * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
			 */
			blockOwnerDeletion?: pulumi.Input<boolean>;
			/**
			 * If true, this reference points to the managing controller.
			 */
			controller?: pulumi.Input<boolean>;
			/**
			 * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
			 */
			name?: pulumi.Input<string>;
			/**
			 * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
			 */
			uid?: pulumi.Input<string>;
		}
	}
}

export namespace traefik {
	export namespace v1alpha1 {
		/**
		 * IngressRoute is the CRD implementation of a Traefik HTTP Router.
		 */
		export interface IngressRoute {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"IngressRoute">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpec>;
		}

		/**
		 * IngressRouteSpec defines the desired state of IngressRoute.
		 */
		export interface IngressRouteSpec {
			/**
			 * EntryPoints defines the list of entry point names to bind to.
			 * Entry points have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/entrypoints/
			 * Default: all.
			 */
			entryPoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Routes defines the list of routes.
			 */
			routes?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutes>[]
			>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTls>;
		}

		/**
		 * IngressRouteSpec defines the desired state of IngressRoute.
		 */
		export interface IngressRouteSpecPatch {
			/**
			 * EntryPoints defines the list of entry point names to bind to.
			 * Entry points have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/entrypoints/
			 * Default: all.
			 */
			entryPoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Routes defines the list of routes.
			 */
			routes?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesPatch>[]
			>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTlsPatch>;
		}

		/**
		 * Route holds the HTTP route configuration.
		 */
		export interface IngressRouteSpecRoutes {
			/**
			 * Kind defines the kind of the route.
			 * Rule is the only supported kind.
			 * If not defined, defaults to Rule.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Match defines the router's rule.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rule
			 */
			match?: pulumi.Input<string>;
			/**
			 * Middlewares defines the list of references to Middleware resources.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-middleware
			 */
			middlewares?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesMiddlewares>[]
			>;
			observability?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesObservability>;
			/**
			 * Priority defines the router's priority.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#priority
			 */
			priority?: pulumi.Input<number>;
			/**
			 * Services defines the list of Service.
			 * It can contain any combination of TraefikService and/or reference to a Kubernetes Service.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServices>[]
			>;
			/**
			 * Syntax defines the router's rule syntax.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rulesyntax
			 * Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
			 */
			syntax?: pulumi.Input<string>;
		}

		/**
		 * MiddlewareRef is a reference to a Middleware resource.
		 */
		export interface IngressRouteSpecRoutesMiddlewares {
			/**
			 * Name defines the name of the referenced Middleware resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Middleware resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * MiddlewareRef is a reference to a Middleware resource.
		 */
		export interface IngressRouteSpecRoutesMiddlewaresPatch {
			/**
			 * Name defines the name of the referenced Middleware resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Middleware resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * Observability defines the observability configuration for a router.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#observability
		 */
		export interface IngressRouteSpecRoutesObservability {
			/**
			 * AccessLogs enables access logs for this router.
			 */
			accessLogs?: pulumi.Input<boolean>;
			/**
			 * Metrics enables metrics for this router.
			 */
			metrics?: pulumi.Input<boolean>;
			/**
			 * TraceVerbosity defines the verbosity level of the tracing for this router.
			 */
			traceVerbosity?: pulumi.Input<string>;
			/**
			 * Tracing enables tracing for this router.
			 */
			tracing?: pulumi.Input<boolean>;
		}

		/**
		 * Observability defines the observability configuration for a router.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#observability
		 */
		export interface IngressRouteSpecRoutesObservabilityPatch {
			/**
			 * AccessLogs enables access logs for this router.
			 */
			accessLogs?: pulumi.Input<boolean>;
			/**
			 * Metrics enables metrics for this router.
			 */
			metrics?: pulumi.Input<boolean>;
			/**
			 * TraceVerbosity defines the verbosity level of the tracing for this router.
			 */
			traceVerbosity?: pulumi.Input<string>;
			/**
			 * Tracing enables tracing for this router.
			 */
			tracing?: pulumi.Input<boolean>;
		}

		/**
		 * Route holds the HTTP route configuration.
		 */
		export interface IngressRouteSpecRoutesPatch {
			/**
			 * Kind defines the kind of the route.
			 * Rule is the only supported kind.
			 * If not defined, defaults to Rule.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Match defines the router's rule.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rule
			 */
			match?: pulumi.Input<string>;
			/**
			 * Middlewares defines the list of references to Middleware resources.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-middleware
			 */
			middlewares?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesMiddlewaresPatch>[]
			>;
			observability?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesObservabilityPatch>;
			/**
			 * Priority defines the router's priority.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#priority
			 */
			priority?: pulumi.Input<number>;
			/**
			 * Services defines the list of Service.
			 * It can contain any combination of TraefikService and/or reference to a Kubernetes Service.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesPatch>[]
			>;
			/**
			 * Syntax defines the router's rule syntax.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rulesyntax
			 * Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
			 */
			syntax?: pulumi.Input<string>;
		}

		/**
		 * Service defines an upstream HTTP service to proxy traffic to.
		 */
		export interface IngressRouteSpecRoutesServices {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesHealthCheck>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesResponseForwarding>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesSticky>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface IngressRouteSpecRoutesServicesHealthCheck {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface IngressRouteSpecRoutesServicesHealthCheckPatch {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Service defines an upstream HTTP service to proxy traffic to.
		 */
		export interface IngressRouteSpecRoutesServicesPatch {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesHealthCheckPatch>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesResponseForwardingPatch>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesStickyPatch>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface IngressRouteSpecRoutesServicesResponseForwarding {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface IngressRouteSpecRoutesServicesResponseForwardingPatch {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface IngressRouteSpecRoutesServicesSticky {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesStickyCookie>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface IngressRouteSpecRoutesServicesStickyCookie {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface IngressRouteSpecRoutesServicesStickyCookiePatch {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface IngressRouteSpecRoutesServicesStickyPatch {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecRoutesServicesStickyCookiePatch>;
		}

		/**
		 * TLS defines the TLS configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#tls
		 */
		export interface IngressRouteSpecTls {
			/**
			 * CertResolver defines the name of the certificate resolver to use.
			 * Cert resolvers have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/acme/#certificate-resolvers
			 */
			certResolver?: pulumi.Input<string>;
			/**
			 * Domains defines the list of domains that will be used to issue certificates.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#domains
			 */
			domains?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTlsDomains>[]
			>;
			options?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTlsOptions>;
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
			store?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTlsStore>;
		}

		/**
		 * Domain holds a domain name with SANs.
		 */
		export interface IngressRouteSpecTlsDomains {
			/**
			 * Main defines the main domain name.
			 */
			main?: pulumi.Input<string>;
			/**
			 * SANs defines the subject alternative domain names.
			 */
			sans?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Domain holds a domain name with SANs.
		 */
		export interface IngressRouteSpecTlsDomainsPatch {
			/**
			 * Main defines the main domain name.
			 */
			main?: pulumi.Input<string>;
			/**
			 * SANs defines the subject alternative domain names.
			 */
			sans?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
		 * If not defined, the `default` TLSOption is used.
		 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#tls-options
		 */
		export interface IngressRouteSpecTlsOptions {
			/**
			 * Name defines the name of the referenced TLSOption.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsoption
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced TLSOption.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsoption
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
		 * If not defined, the `default` TLSOption is used.
		 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#tls-options
		 */
		export interface IngressRouteSpecTlsOptionsPatch {
			/**
			 * Name defines the name of the referenced TLSOption.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsoption
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced TLSOption.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsoption
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * TLS defines the TLS configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#tls
		 */
		export interface IngressRouteSpecTlsPatch {
			/**
			 * CertResolver defines the name of the certificate resolver to use.
			 * Cert resolvers have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/acme/#certificate-resolvers
			 */
			certResolver?: pulumi.Input<string>;
			/**
			 * Domains defines the list of domains that will be used to issue certificates.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#domains
			 */
			domains?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTlsDomainsPatch>[]
			>;
			options?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTlsOptionsPatch>;
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
			store?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteSpecTlsStorePatch>;
		}

		/**
		 * Store defines the reference to the TLSStore, that will be used to store certificates.
		 * Please note that only `default` TLSStore can be used.
		 */
		export interface IngressRouteSpecTlsStore {
			/**
			 * Name defines the name of the referenced TLSStore.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsstore
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced TLSStore.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsstore
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * Store defines the reference to the TLSStore, that will be used to store certificates.
		 * Please note that only `default` TLSStore can be used.
		 */
		export interface IngressRouteSpecTlsStorePatch {
			/**
			 * Name defines the name of the referenced TLSStore.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsstore
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced TLSStore.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-tlsstore
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * IngressRouteTCP is the CRD implementation of a Traefik TCP Router.
		 */
		export interface IngressRouteTCP {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"IngressRouteTCP">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpec>;
		}

		/**
		 * IngressRouteTCPSpec defines the desired state of IngressRouteTCP.
		 */
		export interface IngressRouteTCPSpec {
			/**
			 * EntryPoints defines the list of entry point names to bind to.
			 * Entry points have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/entrypoints/
			 * Default: all.
			 */
			entryPoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Routes defines the list of routes.
			 */
			routes?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutes>[]
			>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTls>;
		}

		/**
		 * IngressRouteTCPSpec defines the desired state of IngressRouteTCP.
		 */
		export interface IngressRouteTCPSpecPatch {
			/**
			 * EntryPoints defines the list of entry point names to bind to.
			 * Entry points have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/entrypoints/
			 * Default: all.
			 */
			entryPoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Routes defines the list of routes.
			 */
			routes?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutesPatch>[]
			>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTlsPatch>;
		}

		/**
		 * RouteTCP holds the TCP route configuration.
		 */
		export interface IngressRouteTCPSpecRoutes {
			/**
			 * Match defines the router's rule.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rule_1
			 */
			match?: pulumi.Input<string>;
			/**
			 * Middlewares defines the list of references to MiddlewareTCP resources.
			 */
			middlewares?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutesMiddlewares>[]
			>;
			/**
			 * Priority defines the router's priority.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#priority_1
			 */
			priority?: pulumi.Input<number>;
			/**
			 * Services defines the list of TCP services.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutesServices>[]
			>;
			/**
			 * Syntax defines the router's rule syntax.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rulesyntax_1
			 * Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
			 */
			syntax?: pulumi.Input<string>;
		}

		/**
		 * ObjectReference is a generic reference to a Traefik resource.
		 */
		export interface IngressRouteTCPSpecRoutesMiddlewares {
			/**
			 * Name defines the name of the referenced Traefik resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Traefik resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * ObjectReference is a generic reference to a Traefik resource.
		 */
		export interface IngressRouteTCPSpecRoutesMiddlewaresPatch {
			/**
			 * Name defines the name of the referenced Traefik resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Traefik resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * RouteTCP holds the TCP route configuration.
		 */
		export interface IngressRouteTCPSpecRoutesPatch {
			/**
			 * Match defines the router's rule.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rule_1
			 */
			match?: pulumi.Input<string>;
			/**
			 * Middlewares defines the list of references to MiddlewareTCP resources.
			 */
			middlewares?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutesMiddlewaresPatch>[]
			>;
			/**
			 * Priority defines the router's priority.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#priority_1
			 */
			priority?: pulumi.Input<number>;
			/**
			 * Services defines the list of TCP services.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutesServicesPatch>[]
			>;
			/**
			 * Syntax defines the router's rule syntax.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#rulesyntax_1
			 * Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
			 */
			syntax?: pulumi.Input<string>;
		}

		/**
		 * ServiceTCP defines an upstream TCP service to proxy traffic to.
		 */
		export interface IngressRouteTCPSpecRoutesServices {
			/**
			 * Name defines the name of the referenced Kubernetes Service.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			proxyProtocol?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutesServicesProxyProtocol>;
			/**
			 * ServersTransport defines the name of ServersTransportTCP resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			/**
			 * TerminationDelay defines the deadline that the proxy sets, after one of its connected peers indicates
			 * it has closed the writing capability of its connection, to close the reading capability as well,
			 * hence fully terminating the connection.
			 * It is a duration in milliseconds, defaulting to 100.
			 * A negative value means an infinite deadline (i.e. the reading capability is never closed).
			 * Deprecated: TerminationDelay will not be supported in future APIVersions, please use ServersTransport to configure the TerminationDelay instead.
			 */
			terminationDelay?: pulumi.Input<number>;
			/**
			 * TLS determines whether to use TLS when dialing with the backend.
			 */
			tls?: pulumi.Input<boolean>;
			/**
			 * Weight defines the weight used when balancing requests between multiple Kubernetes Service.
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ServiceTCP defines an upstream TCP service to proxy traffic to.
		 */
		export interface IngressRouteTCPSpecRoutesServicesPatch {
			/**
			 * Name defines the name of the referenced Kubernetes Service.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			proxyProtocol?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecRoutesServicesProxyProtocolPatch>;
			/**
			 * ServersTransport defines the name of ServersTransportTCP resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			/**
			 * TerminationDelay defines the deadline that the proxy sets, after one of its connected peers indicates
			 * it has closed the writing capability of its connection, to close the reading capability as well,
			 * hence fully terminating the connection.
			 * It is a duration in milliseconds, defaulting to 100.
			 * A negative value means an infinite deadline (i.e. the reading capability is never closed).
			 * Deprecated: TerminationDelay will not be supported in future APIVersions, please use ServersTransport to configure the TerminationDelay instead.
			 */
			terminationDelay?: pulumi.Input<number>;
			/**
			 * TLS determines whether to use TLS when dialing with the backend.
			 */
			tls?: pulumi.Input<boolean>;
			/**
			 * Weight defines the weight used when balancing requests between multiple Kubernetes Service.
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ProxyProtocol defines the PROXY protocol configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#proxy-protocol
		 */
		export interface IngressRouteTCPSpecRoutesServicesProxyProtocol {
			/**
			 * Version defines the PROXY Protocol version to use.
			 */
			version?: pulumi.Input<number>;
		}

		/**
		 * ProxyProtocol defines the PROXY protocol configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#proxy-protocol
		 */
		export interface IngressRouteTCPSpecRoutesServicesProxyProtocolPatch {
			/**
			 * Version defines the PROXY Protocol version to use.
			 */
			version?: pulumi.Input<number>;
		}

		/**
		 * TLS defines the TLS configuration on a layer 4 / TCP Route.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#tls_1
		 */
		export interface IngressRouteTCPSpecTls {
			/**
			 * CertResolver defines the name of the certificate resolver to use.
			 * Cert resolvers have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/acme/#certificate-resolvers
			 */
			certResolver?: pulumi.Input<string>;
			/**
			 * Domains defines the list of domains that will be used to issue certificates.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#domains
			 */
			domains?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTlsDomains>[]
			>;
			options?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTlsOptions>;
			/**
			 * Passthrough defines whether a TLS router will terminate the TLS connection.
			 */
			passthrough?: pulumi.Input<boolean>;
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
			store?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTlsStore>;
		}

		/**
		 * Domain holds a domain name with SANs.
		 */
		export interface IngressRouteTCPSpecTlsDomains {
			/**
			 * Main defines the main domain name.
			 */
			main?: pulumi.Input<string>;
			/**
			 * SANs defines the subject alternative domain names.
			 */
			sans?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Domain holds a domain name with SANs.
		 */
		export interface IngressRouteTCPSpecTlsDomainsPatch {
			/**
			 * Main defines the main domain name.
			 */
			main?: pulumi.Input<string>;
			/**
			 * SANs defines the subject alternative domain names.
			 */
			sans?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
		 * If not defined, the `default` TLSOption is used.
		 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#tls-options
		 */
		export interface IngressRouteTCPSpecTlsOptions {
			/**
			 * Name defines the name of the referenced Traefik resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Traefik resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
		 * If not defined, the `default` TLSOption is used.
		 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#tls-options
		 */
		export interface IngressRouteTCPSpecTlsOptionsPatch {
			/**
			 * Name defines the name of the referenced Traefik resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Traefik resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * TLS defines the TLS configuration on a layer 4 / TCP Route.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#tls_1
		 */
		export interface IngressRouteTCPSpecTlsPatch {
			/**
			 * CertResolver defines the name of the certificate resolver to use.
			 * Cert resolvers have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/acme/#certificate-resolvers
			 */
			certResolver?: pulumi.Input<string>;
			/**
			 * Domains defines the list of domains that will be used to issue certificates.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/routers/#domains
			 */
			domains?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTlsDomainsPatch>[]
			>;
			options?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTlsOptionsPatch>;
			/**
			 * Passthrough defines whether a TLS router will terminate the TLS connection.
			 */
			passthrough?: pulumi.Input<boolean>;
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
			store?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteTCPSpecTlsStorePatch>;
		}

		/**
		 * Store defines the reference to the TLSStore, that will be used to store certificates.
		 * Please note that only `default` TLSStore can be used.
		 */
		export interface IngressRouteTCPSpecTlsStore {
			/**
			 * Name defines the name of the referenced Traefik resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Traefik resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * Store defines the reference to the TLSStore, that will be used to store certificates.
		 * Please note that only `default` TLSStore can be used.
		 */
		export interface IngressRouteTCPSpecTlsStorePatch {
			/**
			 * Name defines the name of the referenced Traefik resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Traefik resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * IngressRouteUDP is a CRD implementation of a Traefik UDP Router.
		 */
		export interface IngressRouteUDP {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"IngressRouteUDP">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.IngressRouteUDPSpec>;
		}

		/**
		 * IngressRouteUDPSpec defines the desired state of a IngressRouteUDP.
		 */
		export interface IngressRouteUDPSpec {
			/**
			 * EntryPoints defines the list of entry point names to bind to.
			 * Entry points have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/entrypoints/
			 * Default: all.
			 */
			entryPoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Routes defines the list of routes.
			 */
			routes?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteUDPSpecRoutes>[]
			>;
		}

		/**
		 * IngressRouteUDPSpec defines the desired state of a IngressRouteUDP.
		 */
		export interface IngressRouteUDPSpecPatch {
			/**
			 * EntryPoints defines the list of entry point names to bind to.
			 * Entry points have to be configured in the static configuration.
			 * More info: https://doc.traefik.io/traefik/v3.5/routing/entrypoints/
			 * Default: all.
			 */
			entryPoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Routes defines the list of routes.
			 */
			routes?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteUDPSpecRoutesPatch>[]
			>;
		}

		/**
		 * RouteUDP holds the UDP route configuration.
		 */
		export interface IngressRouteUDPSpecRoutes {
			/**
			 * Services defines the list of UDP services.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteUDPSpecRoutesServices>[]
			>;
		}

		/**
		 * RouteUDP holds the UDP route configuration.
		 */
		export interface IngressRouteUDPSpecRoutesPatch {
			/**
			 * Services defines the list of UDP services.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.IngressRouteUDPSpecRoutesServicesPatch>[]
			>;
		}

		/**
		 * ServiceUDP defines an upstream UDP service to proxy traffic to.
		 */
		export interface IngressRouteUDPSpecRoutesServices {
			/**
			 * Name defines the name of the referenced Kubernetes Service.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			/**
			 * Weight defines the weight used when balancing requests between multiple Kubernetes Service.
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ServiceUDP defines an upstream UDP service to proxy traffic to.
		 */
		export interface IngressRouteUDPSpecRoutesServicesPatch {
			/**
			 * Name defines the name of the referenced Kubernetes Service.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			/**
			 * Weight defines the weight used when balancing requests between multiple Kubernetes Service.
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * Middleware is the CRD implementation of a Traefik Middleware.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/overview/
		 */
		export interface Middleware {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"Middleware">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpec>;
		}

		/**
		 * MiddlewareSpec defines the desired state of a Middleware.
		 */
		export interface MiddlewareSpec {
			addPrefix?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecAddPrefix>;
			basicAuth?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecBasicAuth>;
			buffering?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecBuffering>;
			chain?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecChain>;
			circuitBreaker?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecCircuitBreaker>;
			compress?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecCompress>;
			contentType?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecContentType>;
			digestAuth?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecDigestAuth>;
			errors?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrors>;
			forwardAuth?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecForwardAuth>;
			grpcWeb?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecGrpcWeb>;
			headers?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecHeaders>;
			inFlightReq?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecInFlightReq>;
			ipAllowList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpAllowList>;
			ipWhiteList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpWhiteList>;
			passTLSClientCert?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCert>;
			/**
			 * Plugin defines the middleware plugin configuration.
			 * More info: https://doc.traefik.io/traefik/plugins/
			 */
			plugin?: pulumi.Input<{
				[key: string]: pulumi.Input<{ [key: string]: any }>;
			}>;
			rateLimit?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimit>;
			redirectRegex?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRedirectRegex>;
			redirectScheme?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRedirectScheme>;
			replacePath?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecReplacePath>;
			replacePathRegex?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecReplacePathRegex>;
			retry?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRetry>;
			stripPrefix?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecStripPrefix>;
			stripPrefixRegex?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecStripPrefixRegex>;
		}

		/**
		 * AddPrefix holds the add prefix middleware configuration.
		 * This middleware updates the path of a request before forwarding it.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/addprefix/
		 */
		export interface MiddlewareSpecAddPrefix {
			/**
			 * Prefix is the string to add before the current path in the requested URL.
			 * It should include a leading slash (/).
			 */
			prefix?: pulumi.Input<string>;
		}

		/**
		 * AddPrefix holds the add prefix middleware configuration.
		 * This middleware updates the path of a request before forwarding it.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/addprefix/
		 */
		export interface MiddlewareSpecAddPrefixPatch {
			/**
			 * Prefix is the string to add before the current path in the requested URL.
			 * It should include a leading slash (/).
			 */
			prefix?: pulumi.Input<string>;
		}

		/**
		 * BasicAuth holds the basic auth middleware configuration.
		 * This middleware restricts access to your services to known users.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/basicauth/
		 */
		export interface MiddlewareSpecBasicAuth {
			/**
			 * HeaderField defines a header field to store the authenticated user.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/basicauth/#headerfield
			 */
			headerField?: pulumi.Input<string>;
			/**
			 * Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
			 * Default: traefik.
			 */
			realm?: pulumi.Input<string>;
			/**
			 * RemoveHeader sets the removeHeader option to true to remove the authorization header before forwarding the request to your service.
			 * Default: false.
			 */
			removeHeader?: pulumi.Input<boolean>;
			/**
			 * Secret is the name of the referenced Kubernetes Secret containing user credentials.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * BasicAuth holds the basic auth middleware configuration.
		 * This middleware restricts access to your services to known users.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/basicauth/
		 */
		export interface MiddlewareSpecBasicAuthPatch {
			/**
			 * HeaderField defines a header field to store the authenticated user.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/basicauth/#headerfield
			 */
			headerField?: pulumi.Input<string>;
			/**
			 * Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
			 * Default: traefik.
			 */
			realm?: pulumi.Input<string>;
			/**
			 * RemoveHeader sets the removeHeader option to true to remove the authorization header before forwarding the request to your service.
			 * Default: false.
			 */
			removeHeader?: pulumi.Input<boolean>;
			/**
			 * Secret is the name of the referenced Kubernetes Secret containing user credentials.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * Buffering holds the buffering middleware configuration.
		 * This middleware retries or limits the size of requests that can be forwarded to backends.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/buffering/#maxrequestbodybytes
		 */
		export interface MiddlewareSpecBuffering {
			/**
			 * MaxRequestBodyBytes defines the maximum allowed body size for the request (in bytes).
			 * If the request exceeds the allowed size, it is not forwarded to the service, and the client gets a 413 (Request Entity Too Large) response.
			 * Default: 0 (no maximum).
			 */
			maxRequestBodyBytes?: pulumi.Input<number>;
			/**
			 * MaxResponseBodyBytes defines the maximum allowed response size from the service (in bytes).
			 * If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 500 (Internal Server Error) response instead.
			 * Default: 0 (no maximum).
			 */
			maxResponseBodyBytes?: pulumi.Input<number>;
			/**
			 * MemRequestBodyBytes defines the threshold (in bytes) from which the request will be buffered on disk instead of in memory.
			 * Default: 1048576 (1Mi).
			 */
			memRequestBodyBytes?: pulumi.Input<number>;
			/**
			 * MemResponseBodyBytes defines the threshold (in bytes) from which the response will be buffered on disk instead of in memory.
			 * Default: 1048576 (1Mi).
			 */
			memResponseBodyBytes?: pulumi.Input<number>;
			/**
			 * RetryExpression defines the retry conditions.
			 * It is a logical combination of functions with operators AND (&&) and OR (||).
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/buffering/#retryexpression
			 */
			retryExpression?: pulumi.Input<string>;
		}

		/**
		 * Buffering holds the buffering middleware configuration.
		 * This middleware retries or limits the size of requests that can be forwarded to backends.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/buffering/#maxrequestbodybytes
		 */
		export interface MiddlewareSpecBufferingPatch {
			/**
			 * MaxRequestBodyBytes defines the maximum allowed body size for the request (in bytes).
			 * If the request exceeds the allowed size, it is not forwarded to the service, and the client gets a 413 (Request Entity Too Large) response.
			 * Default: 0 (no maximum).
			 */
			maxRequestBodyBytes?: pulumi.Input<number>;
			/**
			 * MaxResponseBodyBytes defines the maximum allowed response size from the service (in bytes).
			 * If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 500 (Internal Server Error) response instead.
			 * Default: 0 (no maximum).
			 */
			maxResponseBodyBytes?: pulumi.Input<number>;
			/**
			 * MemRequestBodyBytes defines the threshold (in bytes) from which the request will be buffered on disk instead of in memory.
			 * Default: 1048576 (1Mi).
			 */
			memRequestBodyBytes?: pulumi.Input<number>;
			/**
			 * MemResponseBodyBytes defines the threshold (in bytes) from which the response will be buffered on disk instead of in memory.
			 * Default: 1048576 (1Mi).
			 */
			memResponseBodyBytes?: pulumi.Input<number>;
			/**
			 * RetryExpression defines the retry conditions.
			 * It is a logical combination of functions with operators AND (&&) and OR (||).
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/buffering/#retryexpression
			 */
			retryExpression?: pulumi.Input<string>;
		}

		/**
		 * Chain holds the configuration of the chain middleware.
		 * This middleware enables to define reusable combinations of other pieces of middleware.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/chain/
		 */
		export interface MiddlewareSpecChain {
			/**
			 * Middlewares is the list of MiddlewareRef which composes the chain.
			 */
			middlewares?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecChainMiddlewares>[]
			>;
		}

		/**
		 * MiddlewareRef is a reference to a Middleware resource.
		 */
		export interface MiddlewareSpecChainMiddlewares {
			/**
			 * Name defines the name of the referenced Middleware resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Middleware resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * MiddlewareRef is a reference to a Middleware resource.
		 */
		export interface MiddlewareSpecChainMiddlewaresPatch {
			/**
			 * Name defines the name of the referenced Middleware resource.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Middleware resource.
			 */
			namespace?: pulumi.Input<string>;
		}

		/**
		 * Chain holds the configuration of the chain middleware.
		 * This middleware enables to define reusable combinations of other pieces of middleware.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/chain/
		 */
		export interface MiddlewareSpecChainPatch {
			/**
			 * Middlewares is the list of MiddlewareRef which composes the chain.
			 */
			middlewares?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecChainMiddlewaresPatch>[]
			>;
		}

		/**
		 * CircuitBreaker holds the circuit breaker configuration.
		 */
		export interface MiddlewareSpecCircuitBreaker {
			/**
			 * CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
			 */
			checkPeriod?: pulumi.Input<number | string>;
			/**
			 * Expression is the condition that triggers the tripped state.
			 */
			expression?: pulumi.Input<string>;
			/**
			 * FallbackDuration is the duration for which the circuit breaker will wait before trying to recover (from a tripped state).
			 */
			fallbackDuration?: pulumi.Input<number | string>;
			/**
			 * RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
			 */
			recoveryDuration?: pulumi.Input<number | string>;
			/**
			 * ResponseCode is the status code that the circuit breaker will return while it is in the open state.
			 */
			responseCode?: pulumi.Input<number>;
		}

		/**
		 * CircuitBreaker holds the circuit breaker configuration.
		 */
		export interface MiddlewareSpecCircuitBreakerPatch {
			/**
			 * CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
			 */
			checkPeriod?: pulumi.Input<number | string>;
			/**
			 * Expression is the condition that triggers the tripped state.
			 */
			expression?: pulumi.Input<string>;
			/**
			 * FallbackDuration is the duration for which the circuit breaker will wait before trying to recover (from a tripped state).
			 */
			fallbackDuration?: pulumi.Input<number | string>;
			/**
			 * RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
			 */
			recoveryDuration?: pulumi.Input<number | string>;
			/**
			 * ResponseCode is the status code that the circuit breaker will return while it is in the open state.
			 */
			responseCode?: pulumi.Input<number>;
		}

		/**
		 * Compress holds the compress middleware configuration.
		 * This middleware compresses responses before sending them to the client, using gzip, brotli, or zstd compression.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/compress/
		 */
		export interface MiddlewareSpecCompress {
			/**
			 * DefaultEncoding specifies the default encoding if the `Accept-Encoding` header is not in the request or contains a wildcard (`*`).
			 */
			defaultEncoding?: pulumi.Input<string>;
			/**
			 * Encodings defines the list of supported compression algorithms.
			 */
			encodings?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ExcludedContentTypes defines the list of content types to compare the Content-Type header of the incoming requests and responses before compressing.
			 * `application/grpc` is always excluded.
			 */
			excludedContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IncludedContentTypes defines the list of content types to compare the Content-Type header of the responses before compressing.
			 */
			includedContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MinResponseBodyBytes defines the minimum amount of bytes a response body must have to be compressed.
			 * Default: 1024.
			 */
			minResponseBodyBytes?: pulumi.Input<number>;
		}

		/**
		 * Compress holds the compress middleware configuration.
		 * This middleware compresses responses before sending them to the client, using gzip, brotli, or zstd compression.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/compress/
		 */
		export interface MiddlewareSpecCompressPatch {
			/**
			 * DefaultEncoding specifies the default encoding if the `Accept-Encoding` header is not in the request or contains a wildcard (`*`).
			 */
			defaultEncoding?: pulumi.Input<string>;
			/**
			 * Encodings defines the list of supported compression algorithms.
			 */
			encodings?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ExcludedContentTypes defines the list of content types to compare the Content-Type header of the incoming requests and responses before compressing.
			 * `application/grpc` is always excluded.
			 */
			excludedContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IncludedContentTypes defines the list of content types to compare the Content-Type header of the responses before compressing.
			 */
			includedContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MinResponseBodyBytes defines the minimum amount of bytes a response body must have to be compressed.
			 * Default: 1024.
			 */
			minResponseBodyBytes?: pulumi.Input<number>;
		}

		/**
		 * ContentType holds the content-type middleware configuration.
		 * This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
		 */
		export interface MiddlewareSpecContentType {
			/**
			 * AutoDetect specifies whether to let the `Content-Type` header, if it has not been set by the backend,
			 * be automatically set to a value derived from the contents of the response.
			 * Deprecated: AutoDetect option is deprecated, Content-Type middleware is only meant to be used to enable the content-type detection, please remove any usage of this option.
			 */
			autoDetect?: pulumi.Input<boolean>;
		}

		/**
		 * ContentType holds the content-type middleware configuration.
		 * This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
		 */
		export interface MiddlewareSpecContentTypePatch {
			/**
			 * AutoDetect specifies whether to let the `Content-Type` header, if it has not been set by the backend,
			 * be automatically set to a value derived from the contents of the response.
			 * Deprecated: AutoDetect option is deprecated, Content-Type middleware is only meant to be used to enable the content-type detection, please remove any usage of this option.
			 */
			autoDetect?: pulumi.Input<boolean>;
		}

		/**
		 * DigestAuth holds the digest auth middleware configuration.
		 * This middleware restricts access to your services to known users.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/digestauth/
		 */
		export interface MiddlewareSpecDigestAuth {
			/**
			 * HeaderField defines a header field to store the authenticated user.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/basicauth/#headerfield
			 */
			headerField?: pulumi.Input<string>;
			/**
			 * Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
			 * Default: traefik.
			 */
			realm?: pulumi.Input<string>;
			/**
			 * RemoveHeader defines whether to remove the authorization header before forwarding the request to the backend.
			 */
			removeHeader?: pulumi.Input<boolean>;
			/**
			 * Secret is the name of the referenced Kubernetes Secret containing user credentials.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * DigestAuth holds the digest auth middleware configuration.
		 * This middleware restricts access to your services to known users.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/digestauth/
		 */
		export interface MiddlewareSpecDigestAuthPatch {
			/**
			 * HeaderField defines a header field to store the authenticated user.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/basicauth/#headerfield
			 */
			headerField?: pulumi.Input<string>;
			/**
			 * Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
			 * Default: traefik.
			 */
			realm?: pulumi.Input<string>;
			/**
			 * RemoveHeader defines whether to remove the authorization header before forwarding the request to the backend.
			 */
			removeHeader?: pulumi.Input<boolean>;
			/**
			 * Secret is the name of the referenced Kubernetes Secret containing user credentials.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * ErrorPage holds the custom error middleware configuration.
		 * This middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/errorpages/
		 */
		export interface MiddlewareSpecErrors {
			/**
			 * Query defines the URL for the error page (hosted by service).
			 * The {status} variable can be used in order to insert the status code in the URL.
			 * The {originalStatus} variable can be used in order to insert the upstream status code in the URL.
			 * The {url} variable can be used in order to insert the escaped request URL.
			 */
			query?: pulumi.Input<string>;
			service?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsService>;
			/**
			 * Status defines which status or range of statuses should result in an error page.
			 * It can be either a status code as a number (500),
			 * as multiple comma-separated numbers (500,502),
			 * as ranges by separating two codes with a dash (500-599),
			 * or a combination of the two (404,418,500-599).
			 */
			status?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * StatusRewrites defines a mapping of status codes that should be returned instead of the original error status codes.
			 * For example: "418": 404 or "410-418": 404
			 */
			statusRewrites?: pulumi.Input<{ [key: string]: pulumi.Input<number> }>;
		}

		/**
		 * ErrorPage holds the custom error middleware configuration.
		 * This middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/errorpages/
		 */
		export interface MiddlewareSpecErrorsPatch {
			/**
			 * Query defines the URL for the error page (hosted by service).
			 * The {status} variable can be used in order to insert the status code in the URL.
			 * The {originalStatus} variable can be used in order to insert the upstream status code in the URL.
			 * The {url} variable can be used in order to insert the escaped request URL.
			 */
			query?: pulumi.Input<string>;
			service?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServicePatch>;
			/**
			 * Status defines which status or range of statuses should result in an error page.
			 * It can be either a status code as a number (500),
			 * as multiple comma-separated numbers (500,502),
			 * as ranges by separating two codes with a dash (500-599),
			 * or a combination of the two (404,418,500-599).
			 */
			status?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * StatusRewrites defines a mapping of status codes that should be returned instead of the original error status codes.
			 * For example: "418": 404 or "410-418": 404
			 */
			statusRewrites?: pulumi.Input<{ [key: string]: pulumi.Input<number> }>;
		}

		/**
		 * Service defines the reference to a Kubernetes Service that will serve the error page.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/errorpages/#service
		 */
		export interface MiddlewareSpecErrorsService {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceHealthCheck>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceResponseForwarding>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceSticky>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface MiddlewareSpecErrorsServiceHealthCheck {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface MiddlewareSpecErrorsServiceHealthCheckPatch {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Service defines the reference to a Kubernetes Service that will serve the error page.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/errorpages/#service
		 */
		export interface MiddlewareSpecErrorsServicePatch {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceHealthCheckPatch>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceResponseForwardingPatch>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceStickyPatch>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface MiddlewareSpecErrorsServiceResponseForwarding {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface MiddlewareSpecErrorsServiceResponseForwardingPatch {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface MiddlewareSpecErrorsServiceSticky {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceStickyCookie>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface MiddlewareSpecErrorsServiceStickyCookie {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface MiddlewareSpecErrorsServiceStickyCookiePatch {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface MiddlewareSpecErrorsServiceStickyPatch {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsServiceStickyCookiePatch>;
		}

		/**
		 * ForwardAuth holds the forward auth middleware configuration.
		 * This middleware delegates the request authentication to a Service.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/forwardauth/
		 */
		export interface MiddlewareSpecForwardAuth {
			/**
			 * AddAuthCookiesToResponse defines the list of cookies to copy from the authentication server response to the response.
			 */
			addAuthCookiesToResponse?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Address defines the authentication server address.
			 */
			address?: pulumi.Input<string>;
			/**
			 * AuthRequestHeaders defines the list of the headers to copy from the request to the authentication server.
			 * If not set or empty then all request headers are passed.
			 */
			authRequestHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AuthResponseHeaders defines the list of headers to copy from the authentication server response and set on forwarded request, replacing any existing conflicting headers.
			 */
			authResponseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AuthResponseHeadersRegex defines the regex to match headers to copy from the authentication server response and set on forwarded request, after stripping all headers that match the regex.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/forwardauth/#authresponseheadersregex
			 */
			authResponseHeadersRegex?: pulumi.Input<string>;
			/**
			 * ForwardBody defines whether to send the request body to the authentication server.
			 */
			forwardBody?: pulumi.Input<boolean>;
			/**
			 * HeaderField defines a header field to store the authenticated user.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/forwardauth/#headerfield
			 */
			headerField?: pulumi.Input<string>;
			/**
			 * MaxBodySize defines the maximum body size in bytes allowed to be forwarded to the authentication server.
			 */
			maxBodySize?: pulumi.Input<number>;
			/**
			 * PreserveLocationHeader defines whether to forward the Location header to the client as is or prefix it with the domain name of the authentication server.
			 */
			preserveLocationHeader?: pulumi.Input<boolean>;
			/**
			 * PreserveRequestMethod defines whether to preserve the original request method while forwarding the request to the authentication server.
			 */
			preserveRequestMethod?: pulumi.Input<boolean>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecForwardAuthTls>;
			/**
			 * TrustForwardHeader defines whether to trust (ie: forward) all X-Forwarded-* headers.
			 */
			trustForwardHeader?: pulumi.Input<boolean>;
		}

		/**
		 * ForwardAuth holds the forward auth middleware configuration.
		 * This middleware delegates the request authentication to a Service.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/forwardauth/
		 */
		export interface MiddlewareSpecForwardAuthPatch {
			/**
			 * AddAuthCookiesToResponse defines the list of cookies to copy from the authentication server response to the response.
			 */
			addAuthCookiesToResponse?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * Address defines the authentication server address.
			 */
			address?: pulumi.Input<string>;
			/**
			 * AuthRequestHeaders defines the list of the headers to copy from the request to the authentication server.
			 * If not set or empty then all request headers are passed.
			 */
			authRequestHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AuthResponseHeaders defines the list of headers to copy from the authentication server response and set on forwarded request, replacing any existing conflicting headers.
			 */
			authResponseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AuthResponseHeadersRegex defines the regex to match headers to copy from the authentication server response and set on forwarded request, after stripping all headers that match the regex.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/forwardauth/#authresponseheadersregex
			 */
			authResponseHeadersRegex?: pulumi.Input<string>;
			/**
			 * ForwardBody defines whether to send the request body to the authentication server.
			 */
			forwardBody?: pulumi.Input<boolean>;
			/**
			 * HeaderField defines a header field to store the authenticated user.
			 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/forwardauth/#headerfield
			 */
			headerField?: pulumi.Input<string>;
			/**
			 * MaxBodySize defines the maximum body size in bytes allowed to be forwarded to the authentication server.
			 */
			maxBodySize?: pulumi.Input<number>;
			/**
			 * PreserveLocationHeader defines whether to forward the Location header to the client as is or prefix it with the domain name of the authentication server.
			 */
			preserveLocationHeader?: pulumi.Input<boolean>;
			/**
			 * PreserveRequestMethod defines whether to preserve the original request method while forwarding the request to the authentication server.
			 */
			preserveRequestMethod?: pulumi.Input<boolean>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecForwardAuthTlsPatch>;
			/**
			 * TrustForwardHeader defines whether to trust (ie: forward) all X-Forwarded-* headers.
			 */
			trustForwardHeader?: pulumi.Input<boolean>;
		}

		/**
		 * TLS defines the configuration used to secure the connection to the authentication server.
		 */
		export interface MiddlewareSpecForwardAuthTls {
			/**
			 * Deprecated: TLS client authentication is a server side option (see https://github.com/golang/go/blob/740a490f71d026bb7d2d13cb8fa2d6d6e0572b70/src/crypto/tls/common.go#L634).
			 */
			caOptional?: pulumi.Input<boolean>;
			/**
			 * CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
			 * The CA certificate is extracted from key `tls.ca` or `ca.crt`.
			 */
			caSecret?: pulumi.Input<string>;
			/**
			 * CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
			 * The client certificate is extracted from the keys `tls.crt` and `tls.key`.
			 */
			certSecret?: pulumi.Input<string>;
			/**
			 * InsecureSkipVerify defines whether the server certificates should be validated.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
		}

		/**
		 * TLS defines the configuration used to secure the connection to the authentication server.
		 */
		export interface MiddlewareSpecForwardAuthTlsPatch {
			/**
			 * Deprecated: TLS client authentication is a server side option (see https://github.com/golang/go/blob/740a490f71d026bb7d2d13cb8fa2d6d6e0572b70/src/crypto/tls/common.go#L634).
			 */
			caOptional?: pulumi.Input<boolean>;
			/**
			 * CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
			 * The CA certificate is extracted from key `tls.ca` or `ca.crt`.
			 */
			caSecret?: pulumi.Input<string>;
			/**
			 * CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
			 * The client certificate is extracted from the keys `tls.crt` and `tls.key`.
			 */
			certSecret?: pulumi.Input<string>;
			/**
			 * InsecureSkipVerify defines whether the server certificates should be validated.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
		}

		/**
		 * GrpcWeb holds the gRPC web middleware configuration.
		 * This middleware converts a gRPC web request to an HTTP/2 gRPC request.
		 */
		export interface MiddlewareSpecGrpcWeb {
			/**
			 * AllowOrigins is a list of allowable origins.
			 * Can also be a wildcard origin "*".
			 */
			allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * GrpcWeb holds the gRPC web middleware configuration.
		 * This middleware converts a gRPC web request to an HTTP/2 gRPC request.
		 */
		export interface MiddlewareSpecGrpcWebPatch {
			/**
			 * AllowOrigins is a list of allowable origins.
			 * Can also be a wildcard origin "*".
			 */
			allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Headers holds the headers middleware configuration.
		 * This middleware manages the requests and responses headers.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/headers/#customrequestheaders
		 */
		export interface MiddlewareSpecHeaders {
			/**
			 * AccessControlAllowCredentials defines whether the request can include user credentials.
			 */
			accessControlAllowCredentials?: pulumi.Input<boolean>;
			/**
			 * AccessControlAllowHeaders defines the Access-Control-Request-Headers values sent in preflight response.
			 */
			accessControlAllowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlAllowMethods defines the Access-Control-Request-Method values sent in preflight response.
			 */
			accessControlAllowMethods?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlAllowOriginList is a list of allowable origins. Can also be a wildcard origin "*".
			 */
			accessControlAllowOriginList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlAllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
			 */
			accessControlAllowOriginListRegex?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlExposeHeaders defines the Access-Control-Expose-Headers values sent in preflight response.
			 */
			accessControlExposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlMaxAge defines the time that a preflight request may be cached.
			 */
			accessControlMaxAge?: pulumi.Input<number>;
			/**
			 * AddVaryHeader defines whether the Vary header is automatically added/updated when the AccessControlAllowOriginList is set.
			 */
			addVaryHeader?: pulumi.Input<boolean>;
			/**
			 * AllowedHosts defines the fully qualified list of allowed domain names.
			 */
			allowedHosts?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * BrowserXSSFilter defines whether to add the X-XSS-Protection header with the value 1; mode=block.
			 */
			browserXssFilter?: pulumi.Input<boolean>;
			/**
			 * ContentSecurityPolicy defines the Content-Security-Policy header value.
			 */
			contentSecurityPolicy?: pulumi.Input<string>;
			/**
			 * ContentSecurityPolicyReportOnly defines the Content-Security-Policy-Report-Only header value.
			 */
			contentSecurityPolicyReportOnly?: pulumi.Input<string>;
			/**
			 * ContentTypeNosniff defines whether to add the X-Content-Type-Options header with the nosniff value.
			 */
			contentTypeNosniff?: pulumi.Input<boolean>;
			/**
			 * CustomBrowserXSSValue defines the X-XSS-Protection header value.
			 * This overrides the BrowserXssFilter option.
			 */
			customBrowserXSSValue?: pulumi.Input<string>;
			/**
			 * CustomFrameOptionsValue defines the X-Frame-Options header value.
			 * This overrides the FrameDeny option.
			 */
			customFrameOptionsValue?: pulumi.Input<string>;
			/**
			 * CustomRequestHeaders defines the header names and values to apply to the request.
			 */
			customRequestHeaders?: pulumi.Input<{
				[key: string]: pulumi.Input<string>;
			}>;
			/**
			 * CustomResponseHeaders defines the header names and values to apply to the response.
			 */
			customResponseHeaders?: pulumi.Input<{
				[key: string]: pulumi.Input<string>;
			}>;
			/**
			 * Deprecated: FeaturePolicy option is deprecated, please use PermissionsPolicy instead.
			 */
			featurePolicy?: pulumi.Input<string>;
			/**
			 * ForceSTSHeader defines whether to add the STS header even when the connection is HTTP.
			 */
			forceSTSHeader?: pulumi.Input<boolean>;
			/**
			 * FrameDeny defines whether to add the X-Frame-Options header with the DENY value.
			 */
			frameDeny?: pulumi.Input<boolean>;
			/**
			 * HostsProxyHeaders defines the header keys that may hold a proxied hostname value for the request.
			 */
			hostsProxyHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IsDevelopment defines whether to mitigate the unwanted effects of the AllowedHosts, SSL, and STS options when developing.
			 * Usually testing takes place using HTTP, not HTTPS, and on localhost, not your production domain.
			 * If you would like your development environment to mimic production with complete Host blocking, SSL redirects,
			 * and STS headers, leave this as false.
			 */
			isDevelopment?: pulumi.Input<boolean>;
			/**
			 * PermissionsPolicy defines the Permissions-Policy header value.
			 * This allows sites to control browser features.
			 */
			permissionsPolicy?: pulumi.Input<string>;
			/**
			 * PublicKey is the public key that implements HPKP to prevent MITM attacks with forged certificates.
			 */
			publicKey?: pulumi.Input<string>;
			/**
			 * ReferrerPolicy defines the Referrer-Policy header value.
			 * This allows sites to control whether browsers forward the Referer header to other sites.
			 */
			referrerPolicy?: pulumi.Input<string>;
			/**
			 * Deprecated: SSLForceHost option is deprecated, please use RedirectRegex instead.
			 */
			sslForceHost?: pulumi.Input<boolean>;
			/**
			 * Deprecated: SSLHost option is deprecated, please use RedirectRegex instead.
			 */
			sslHost?: pulumi.Input<string>;
			/**
			 * SSLProxyHeaders defines the header keys with associated values that would indicate a valid HTTPS request.
			 * It can be useful when using other proxies (example: "X-Forwarded-Proto": "https").
			 */
			sslProxyHeaders?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Deprecated: SSLRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
			 */
			sslRedirect?: pulumi.Input<boolean>;
			/**
			 * Deprecated: SSLTemporaryRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
			 */
			sslTemporaryRedirect?: pulumi.Input<boolean>;
			/**
			 * STSIncludeSubdomains defines whether the includeSubDomains directive is appended to the Strict-Transport-Security header.
			 */
			stsIncludeSubdomains?: pulumi.Input<boolean>;
			/**
			 * STSPreload defines whether the preload flag is appended to the Strict-Transport-Security header.
			 */
			stsPreload?: pulumi.Input<boolean>;
			/**
			 * STSSeconds defines the max-age of the Strict-Transport-Security header.
			 * If set to 0, the header is not set.
			 */
			stsSeconds?: pulumi.Input<number>;
		}

		/**
		 * Headers holds the headers middleware configuration.
		 * This middleware manages the requests and responses headers.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/headers/#customrequestheaders
		 */
		export interface MiddlewareSpecHeadersPatch {
			/**
			 * AccessControlAllowCredentials defines whether the request can include user credentials.
			 */
			accessControlAllowCredentials?: pulumi.Input<boolean>;
			/**
			 * AccessControlAllowHeaders defines the Access-Control-Request-Headers values sent in preflight response.
			 */
			accessControlAllowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlAllowMethods defines the Access-Control-Request-Method values sent in preflight response.
			 */
			accessControlAllowMethods?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlAllowOriginList is a list of allowable origins. Can also be a wildcard origin "*".
			 */
			accessControlAllowOriginList?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlAllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
			 */
			accessControlAllowOriginListRegex?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlExposeHeaders defines the Access-Control-Expose-Headers values sent in preflight response.
			 */
			accessControlExposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * AccessControlMaxAge defines the time that a preflight request may be cached.
			 */
			accessControlMaxAge?: pulumi.Input<number>;
			/**
			 * AddVaryHeader defines whether the Vary header is automatically added/updated when the AccessControlAllowOriginList is set.
			 */
			addVaryHeader?: pulumi.Input<boolean>;
			/**
			 * AllowedHosts defines the fully qualified list of allowed domain names.
			 */
			allowedHosts?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * BrowserXSSFilter defines whether to add the X-XSS-Protection header with the value 1; mode=block.
			 */
			browserXssFilter?: pulumi.Input<boolean>;
			/**
			 * ContentSecurityPolicy defines the Content-Security-Policy header value.
			 */
			contentSecurityPolicy?: pulumi.Input<string>;
			/**
			 * ContentSecurityPolicyReportOnly defines the Content-Security-Policy-Report-Only header value.
			 */
			contentSecurityPolicyReportOnly?: pulumi.Input<string>;
			/**
			 * ContentTypeNosniff defines whether to add the X-Content-Type-Options header with the nosniff value.
			 */
			contentTypeNosniff?: pulumi.Input<boolean>;
			/**
			 * CustomBrowserXSSValue defines the X-XSS-Protection header value.
			 * This overrides the BrowserXssFilter option.
			 */
			customBrowserXSSValue?: pulumi.Input<string>;
			/**
			 * CustomFrameOptionsValue defines the X-Frame-Options header value.
			 * This overrides the FrameDeny option.
			 */
			customFrameOptionsValue?: pulumi.Input<string>;
			/**
			 * CustomRequestHeaders defines the header names and values to apply to the request.
			 */
			customRequestHeaders?: pulumi.Input<{
				[key: string]: pulumi.Input<string>;
			}>;
			/**
			 * CustomResponseHeaders defines the header names and values to apply to the response.
			 */
			customResponseHeaders?: pulumi.Input<{
				[key: string]: pulumi.Input<string>;
			}>;
			/**
			 * Deprecated: FeaturePolicy option is deprecated, please use PermissionsPolicy instead.
			 */
			featurePolicy?: pulumi.Input<string>;
			/**
			 * ForceSTSHeader defines whether to add the STS header even when the connection is HTTP.
			 */
			forceSTSHeader?: pulumi.Input<boolean>;
			/**
			 * FrameDeny defines whether to add the X-Frame-Options header with the DENY value.
			 */
			frameDeny?: pulumi.Input<boolean>;
			/**
			 * HostsProxyHeaders defines the header keys that may hold a proxied hostname value for the request.
			 */
			hostsProxyHeaders?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IsDevelopment defines whether to mitigate the unwanted effects of the AllowedHosts, SSL, and STS options when developing.
			 * Usually testing takes place using HTTP, not HTTPS, and on localhost, not your production domain.
			 * If you would like your development environment to mimic production with complete Host blocking, SSL redirects,
			 * and STS headers, leave this as false.
			 */
			isDevelopment?: pulumi.Input<boolean>;
			/**
			 * PermissionsPolicy defines the Permissions-Policy header value.
			 * This allows sites to control browser features.
			 */
			permissionsPolicy?: pulumi.Input<string>;
			/**
			 * PublicKey is the public key that implements HPKP to prevent MITM attacks with forged certificates.
			 */
			publicKey?: pulumi.Input<string>;
			/**
			 * ReferrerPolicy defines the Referrer-Policy header value.
			 * This allows sites to control whether browsers forward the Referer header to other sites.
			 */
			referrerPolicy?: pulumi.Input<string>;
			/**
			 * Deprecated: SSLForceHost option is deprecated, please use RedirectRegex instead.
			 */
			sslForceHost?: pulumi.Input<boolean>;
			/**
			 * Deprecated: SSLHost option is deprecated, please use RedirectRegex instead.
			 */
			sslHost?: pulumi.Input<string>;
			/**
			 * SSLProxyHeaders defines the header keys with associated values that would indicate a valid HTTPS request.
			 * It can be useful when using other proxies (example: "X-Forwarded-Proto": "https").
			 */
			sslProxyHeaders?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Deprecated: SSLRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
			 */
			sslRedirect?: pulumi.Input<boolean>;
			/**
			 * Deprecated: SSLTemporaryRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
			 */
			sslTemporaryRedirect?: pulumi.Input<boolean>;
			/**
			 * STSIncludeSubdomains defines whether the includeSubDomains directive is appended to the Strict-Transport-Security header.
			 */
			stsIncludeSubdomains?: pulumi.Input<boolean>;
			/**
			 * STSPreload defines whether the preload flag is appended to the Strict-Transport-Security header.
			 */
			stsPreload?: pulumi.Input<boolean>;
			/**
			 * STSSeconds defines the max-age of the Strict-Transport-Security header.
			 * If set to 0, the header is not set.
			 */
			stsSeconds?: pulumi.Input<number>;
		}

		/**
		 * InFlightReq holds the in-flight request middleware configuration.
		 * This middleware limits the number of requests being processed and served concurrently.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/inflightreq/
		 */
		export interface MiddlewareSpecInFlightReq {
			/**
			 * Amount defines the maximum amount of allowed simultaneous in-flight request.
			 * The middleware responds with HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy).
			 */
			amount?: pulumi.Input<number>;
			sourceCriterion?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecInFlightReqSourceCriterion>;
		}

		/**
		 * InFlightReq holds the in-flight request middleware configuration.
		 * This middleware limits the number of requests being processed and served concurrently.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/inflightreq/
		 */
		export interface MiddlewareSpecInFlightReqPatch {
			/**
			 * Amount defines the maximum amount of allowed simultaneous in-flight request.
			 * The middleware responds with HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy).
			 */
			amount?: pulumi.Input<number>;
			sourceCriterion?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecInFlightReqSourceCriterionPatch>;
		}

		/**
		 * SourceCriterion defines what criterion is used to group requests as originating from a common source.
		 * If several strategies are defined at the same time, an error will be raised.
		 * If none are set, the default is to use the requestHost.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/inflightreq/#sourcecriterion
		 */
		export interface MiddlewareSpecInFlightReqSourceCriterion {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecInFlightReqSourceCriterionIpStrategy>;
			/**
			 * RequestHeaderName defines the name of the header used to group incoming requests.
			 */
			requestHeaderName?: pulumi.Input<string>;
			/**
			 * RequestHost defines whether to consider the request Host as the source.
			 */
			requestHost?: pulumi.Input<boolean>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecInFlightReqSourceCriterionIpStrategy {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecInFlightReqSourceCriterionIpStrategyPatch {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * SourceCriterion defines what criterion is used to group requests as originating from a common source.
		 * If several strategies are defined at the same time, an error will be raised.
		 * If none are set, the default is to use the requestHost.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/inflightreq/#sourcecriterion
		 */
		export interface MiddlewareSpecInFlightReqSourceCriterionPatch {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecInFlightReqSourceCriterionIpStrategyPatch>;
			/**
			 * RequestHeaderName defines the name of the header used to group incoming requests.
			 */
			requestHeaderName?: pulumi.Input<string>;
			/**
			 * RequestHost defines whether to consider the request Host as the source.
			 */
			requestHost?: pulumi.Input<boolean>;
		}

		/**
		 * IPAllowList holds the IP allowlist middleware configuration.
		 * This middleware limits allowed requests based on the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/
		 */
		export interface MiddlewareSpecIpAllowList {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpAllowListIpStrategy>;
			/**
			 * RejectStatusCode defines the HTTP status code used for refused requests.
			 * If not set, the default is 403 (Forbidden).
			 */
			rejectStatusCode?: pulumi.Input<number>;
			/**
			 * SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation).
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecIpAllowListIpStrategy {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecIpAllowListIpStrategyPatch {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * IPAllowList holds the IP allowlist middleware configuration.
		 * This middleware limits allowed requests based on the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/
		 */
		export interface MiddlewareSpecIpAllowListPatch {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpAllowListIpStrategyPatch>;
			/**
			 * RejectStatusCode defines the HTTP status code used for refused requests.
			 * If not set, the default is 403 (Forbidden).
			 */
			rejectStatusCode?: pulumi.Input<number>;
			/**
			 * SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation).
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Deprecated: please use IPAllowList instead.
		 */
		export interface MiddlewareSpecIpWhiteList {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpWhiteListIpStrategy>;
			/**
			 * SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation). Required.
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecIpWhiteListIpStrategy {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecIpWhiteListIpStrategyPatch {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * Deprecated: please use IPAllowList instead.
		 */
		export interface MiddlewareSpecIpWhiteListPatch {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpWhiteListIpStrategyPatch>;
			/**
			 * SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation). Required.
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * PassTLSClientCert holds the pass TLS client cert middleware configuration.
		 * This middleware adds the selected data from the passed client TLS certificate to a header.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/passtlsclientcert/
		 */
		export interface MiddlewareSpecPassTLSClientCert {
			info?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCertInfo>;
			/**
			 * PEM sets the X-Forwarded-Tls-Client-Cert header with the certificate.
			 */
			pem?: pulumi.Input<boolean>;
		}

		/**
		 * Info selects the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header.
		 */
		export interface MiddlewareSpecPassTLSClientCertInfo {
			issuer?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCertInfoIssuer>;
			/**
			 * NotAfter defines whether to add the Not After information from the Validity part.
			 */
			notAfter?: pulumi.Input<boolean>;
			/**
			 * NotBefore defines whether to add the Not Before information from the Validity part.
			 */
			notBefore?: pulumi.Input<boolean>;
			/**
			 * Sans defines whether to add the Subject Alternative Name information from the Subject Alternative Name part.
			 */
			sans?: pulumi.Input<boolean>;
			/**
			 * SerialNumber defines whether to add the client serialNumber information.
			 */
			serialNumber?: pulumi.Input<boolean>;
			subject?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCertInfoSubject>;
		}

		/**
		 * Issuer defines the client certificate issuer details to add to the X-Forwarded-Tls-Client-Cert-Info header.
		 */
		export interface MiddlewareSpecPassTLSClientCertInfoIssuer {
			/**
			 * CommonName defines whether to add the organizationalUnit information into the issuer.
			 */
			commonName?: pulumi.Input<boolean>;
			/**
			 * Country defines whether to add the country information into the issuer.
			 */
			country?: pulumi.Input<boolean>;
			/**
			 * DomainComponent defines whether to add the domainComponent information into the issuer.
			 */
			domainComponent?: pulumi.Input<boolean>;
			/**
			 * Locality defines whether to add the locality information into the issuer.
			 */
			locality?: pulumi.Input<boolean>;
			/**
			 * Organization defines whether to add the organization information into the issuer.
			 */
			organization?: pulumi.Input<boolean>;
			/**
			 * Province defines whether to add the province information into the issuer.
			 */
			province?: pulumi.Input<boolean>;
			/**
			 * SerialNumber defines whether to add the serialNumber information into the issuer.
			 */
			serialNumber?: pulumi.Input<boolean>;
		}

		/**
		 * Issuer defines the client certificate issuer details to add to the X-Forwarded-Tls-Client-Cert-Info header.
		 */
		export interface MiddlewareSpecPassTLSClientCertInfoIssuerPatch {
			/**
			 * CommonName defines whether to add the organizationalUnit information into the issuer.
			 */
			commonName?: pulumi.Input<boolean>;
			/**
			 * Country defines whether to add the country information into the issuer.
			 */
			country?: pulumi.Input<boolean>;
			/**
			 * DomainComponent defines whether to add the domainComponent information into the issuer.
			 */
			domainComponent?: pulumi.Input<boolean>;
			/**
			 * Locality defines whether to add the locality information into the issuer.
			 */
			locality?: pulumi.Input<boolean>;
			/**
			 * Organization defines whether to add the organization information into the issuer.
			 */
			organization?: pulumi.Input<boolean>;
			/**
			 * Province defines whether to add the province information into the issuer.
			 */
			province?: pulumi.Input<boolean>;
			/**
			 * SerialNumber defines whether to add the serialNumber information into the issuer.
			 */
			serialNumber?: pulumi.Input<boolean>;
		}

		/**
		 * Info selects the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header.
		 */
		export interface MiddlewareSpecPassTLSClientCertInfoPatch {
			issuer?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCertInfoIssuerPatch>;
			/**
			 * NotAfter defines whether to add the Not After information from the Validity part.
			 */
			notAfter?: pulumi.Input<boolean>;
			/**
			 * NotBefore defines whether to add the Not Before information from the Validity part.
			 */
			notBefore?: pulumi.Input<boolean>;
			/**
			 * Sans defines whether to add the Subject Alternative Name information from the Subject Alternative Name part.
			 */
			sans?: pulumi.Input<boolean>;
			/**
			 * SerialNumber defines whether to add the client serialNumber information.
			 */
			serialNumber?: pulumi.Input<boolean>;
			subject?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCertInfoSubjectPatch>;
		}

		/**
		 * Subject defines the client certificate subject details to add to the X-Forwarded-Tls-Client-Cert-Info header.
		 */
		export interface MiddlewareSpecPassTLSClientCertInfoSubject {
			/**
			 * CommonName defines whether to add the organizationalUnit information into the subject.
			 */
			commonName?: pulumi.Input<boolean>;
			/**
			 * Country defines whether to add the country information into the subject.
			 */
			country?: pulumi.Input<boolean>;
			/**
			 * DomainComponent defines whether to add the domainComponent information into the subject.
			 */
			domainComponent?: pulumi.Input<boolean>;
			/**
			 * Locality defines whether to add the locality information into the subject.
			 */
			locality?: pulumi.Input<boolean>;
			/**
			 * Organization defines whether to add the organization information into the subject.
			 */
			organization?: pulumi.Input<boolean>;
			/**
			 * OrganizationalUnit defines whether to add the organizationalUnit information into the subject.
			 */
			organizationalUnit?: pulumi.Input<boolean>;
			/**
			 * Province defines whether to add the province information into the subject.
			 */
			province?: pulumi.Input<boolean>;
			/**
			 * SerialNumber defines whether to add the serialNumber information into the subject.
			 */
			serialNumber?: pulumi.Input<boolean>;
		}

		/**
		 * Subject defines the client certificate subject details to add to the X-Forwarded-Tls-Client-Cert-Info header.
		 */
		export interface MiddlewareSpecPassTLSClientCertInfoSubjectPatch {
			/**
			 * CommonName defines whether to add the organizationalUnit information into the subject.
			 */
			commonName?: pulumi.Input<boolean>;
			/**
			 * Country defines whether to add the country information into the subject.
			 */
			country?: pulumi.Input<boolean>;
			/**
			 * DomainComponent defines whether to add the domainComponent information into the subject.
			 */
			domainComponent?: pulumi.Input<boolean>;
			/**
			 * Locality defines whether to add the locality information into the subject.
			 */
			locality?: pulumi.Input<boolean>;
			/**
			 * Organization defines whether to add the organization information into the subject.
			 */
			organization?: pulumi.Input<boolean>;
			/**
			 * OrganizationalUnit defines whether to add the organizationalUnit information into the subject.
			 */
			organizationalUnit?: pulumi.Input<boolean>;
			/**
			 * Province defines whether to add the province information into the subject.
			 */
			province?: pulumi.Input<boolean>;
			/**
			 * SerialNumber defines whether to add the serialNumber information into the subject.
			 */
			serialNumber?: pulumi.Input<boolean>;
		}

		/**
		 * PassTLSClientCert holds the pass TLS client cert middleware configuration.
		 * This middleware adds the selected data from the passed client TLS certificate to a header.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/passtlsclientcert/
		 */
		export interface MiddlewareSpecPassTLSClientCertPatch {
			info?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCertInfoPatch>;
			/**
			 * PEM sets the X-Forwarded-Tls-Client-Cert header with the certificate.
			 */
			pem?: pulumi.Input<boolean>;
		}

		/**
		 * MiddlewareSpec defines the desired state of a Middleware.
		 */
		export interface MiddlewareSpecPatch {
			addPrefix?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecAddPrefixPatch>;
			basicAuth?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecBasicAuthPatch>;
			buffering?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecBufferingPatch>;
			chain?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecChainPatch>;
			circuitBreaker?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecCircuitBreakerPatch>;
			compress?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecCompressPatch>;
			contentType?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecContentTypePatch>;
			digestAuth?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecDigestAuthPatch>;
			errors?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecErrorsPatch>;
			forwardAuth?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecForwardAuthPatch>;
			grpcWeb?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecGrpcWebPatch>;
			headers?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecHeadersPatch>;
			inFlightReq?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecInFlightReqPatch>;
			ipAllowList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpAllowListPatch>;
			ipWhiteList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecIpWhiteListPatch>;
			passTLSClientCert?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecPassTLSClientCertPatch>;
			/**
			 * Plugin defines the middleware plugin configuration.
			 * More info: https://doc.traefik.io/traefik/plugins/
			 */
			plugin?: pulumi.Input<{
				[key: string]: pulumi.Input<{ [key: string]: any }>;
			}>;
			rateLimit?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitPatch>;
			redirectRegex?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRedirectRegexPatch>;
			redirectScheme?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRedirectSchemePatch>;
			replacePath?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecReplacePathPatch>;
			replacePathRegex?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecReplacePathRegexPatch>;
			retry?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRetryPatch>;
			stripPrefix?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecStripPrefixPatch>;
			stripPrefixRegex?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecStripPrefixRegexPatch>;
		}

		/**
		 * RateLimit holds the rate limit configuration.
		 * This middleware ensures that services will receive a fair amount of requests, and allows one to define what fair is.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ratelimit/
		 */
		export interface MiddlewareSpecRateLimit {
			/**
			 * Average is the maximum rate, by default in requests/s, allowed for the given source.
			 * It defaults to 0, which means no rate limiting.
			 * The rate is actually defined by dividing Average by Period. So for a rate below 1req/s,
			 * one needs to define a Period larger than a second.
			 */
			average?: pulumi.Input<number>;
			/**
			 * Burst is the maximum number of requests allowed to arrive in the same arbitrarily small period of time.
			 * It defaults to 1.
			 */
			burst?: pulumi.Input<number>;
			/**
			 * Period, in combination with Average, defines the actual maximum rate, such as:
			 * r = Average / Period. It defaults to a second.
			 */
			period?: pulumi.Input<number | string>;
			redis?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitRedis>;
			sourceCriterion?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitSourceCriterion>;
		}

		/**
		 * RateLimit holds the rate limit configuration.
		 * This middleware ensures that services will receive a fair amount of requests, and allows one to define what fair is.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ratelimit/
		 */
		export interface MiddlewareSpecRateLimitPatch {
			/**
			 * Average is the maximum rate, by default in requests/s, allowed for the given source.
			 * It defaults to 0, which means no rate limiting.
			 * The rate is actually defined by dividing Average by Period. So for a rate below 1req/s,
			 * one needs to define a Period larger than a second.
			 */
			average?: pulumi.Input<number>;
			/**
			 * Burst is the maximum number of requests allowed to arrive in the same arbitrarily small period of time.
			 * It defaults to 1.
			 */
			burst?: pulumi.Input<number>;
			/**
			 * Period, in combination with Average, defines the actual maximum rate, such as:
			 * r = Average / Period. It defaults to a second.
			 */
			period?: pulumi.Input<number | string>;
			redis?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitRedisPatch>;
			sourceCriterion?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitSourceCriterionPatch>;
		}

		/**
		 * Redis hold the configs of Redis as bucket in rate limiter.
		 */
		export interface MiddlewareSpecRateLimitRedis {
			/**
			 * DB defines the Redis database that will be selected after connecting to the server.
			 */
			db?: pulumi.Input<number>;
			/**
			 * DialTimeout sets the timeout for establishing new connections.
			 * Default value is 5 seconds.
			 */
			dialTimeout?: pulumi.Input<number | string>;
			/**
			 * Endpoints contains either a single address or a seed list of host:port addresses.
			 * Default value is ["localhost:6379"].
			 */
			endpoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MaxActiveConns defines the maximum number of connections allocated by the pool at a given time.
			 * Default value is 0, meaning there is no limit.
			 */
			maxActiveConns?: pulumi.Input<number>;
			/**
			 * MinIdleConns defines the minimum number of idle connections.
			 * Default value is 0, and idle connections are not closed by default.
			 */
			minIdleConns?: pulumi.Input<number>;
			/**
			 * PoolSize defines the initial number of socket connections.
			 * If the pool runs out of available connections, additional ones will be created beyond PoolSize.
			 * This can be limited using MaxActiveConns.
			 * // Default value is 0, meaning 10 connections per every available CPU as reported by runtime.GOMAXPROCS.
			 */
			poolSize?: pulumi.Input<number>;
			/**
			 * ReadTimeout defines the timeout for socket read operations.
			 * Default value is 3 seconds.
			 */
			readTimeout?: pulumi.Input<number | string>;
			/**
			 * Secret defines the name of the referenced Kubernetes Secret containing Redis credentials.
			 */
			secret?: pulumi.Input<string>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitRedisTls>;
			/**
			 * WriteTimeout defines the timeout for socket write operations.
			 * Default value is 3 seconds.
			 */
			writeTimeout?: pulumi.Input<number | string>;
		}

		/**
		 * Redis hold the configs of Redis as bucket in rate limiter.
		 */
		export interface MiddlewareSpecRateLimitRedisPatch {
			/**
			 * DB defines the Redis database that will be selected after connecting to the server.
			 */
			db?: pulumi.Input<number>;
			/**
			 * DialTimeout sets the timeout for establishing new connections.
			 * Default value is 5 seconds.
			 */
			dialTimeout?: pulumi.Input<number | string>;
			/**
			 * Endpoints contains either a single address or a seed list of host:port addresses.
			 * Default value is ["localhost:6379"].
			 */
			endpoints?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * MaxActiveConns defines the maximum number of connections allocated by the pool at a given time.
			 * Default value is 0, meaning there is no limit.
			 */
			maxActiveConns?: pulumi.Input<number>;
			/**
			 * MinIdleConns defines the minimum number of idle connections.
			 * Default value is 0, and idle connections are not closed by default.
			 */
			minIdleConns?: pulumi.Input<number>;
			/**
			 * PoolSize defines the initial number of socket connections.
			 * If the pool runs out of available connections, additional ones will be created beyond PoolSize.
			 * This can be limited using MaxActiveConns.
			 * // Default value is 0, meaning 10 connections per every available CPU as reported by runtime.GOMAXPROCS.
			 */
			poolSize?: pulumi.Input<number>;
			/**
			 * ReadTimeout defines the timeout for socket read operations.
			 * Default value is 3 seconds.
			 */
			readTimeout?: pulumi.Input<number | string>;
			/**
			 * Secret defines the name of the referenced Kubernetes Secret containing Redis credentials.
			 */
			secret?: pulumi.Input<string>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitRedisTlsPatch>;
			/**
			 * WriteTimeout defines the timeout for socket write operations.
			 * Default value is 3 seconds.
			 */
			writeTimeout?: pulumi.Input<number | string>;
		}

		/**
		 * TLS defines TLS-specific configurations, including the CA, certificate, and key,
		 * which can be provided as a file path or file content.
		 */
		export interface MiddlewareSpecRateLimitRedisTls {
			/**
			 * CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
			 * The CA certificate is extracted from key `tls.ca` or `ca.crt`.
			 */
			caSecret?: pulumi.Input<string>;
			/**
			 * CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
			 * The client certificate is extracted from the keys `tls.crt` and `tls.key`.
			 */
			certSecret?: pulumi.Input<string>;
			/**
			 * InsecureSkipVerify defines whether the server certificates should be validated.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
		}

		/**
		 * TLS defines TLS-specific configurations, including the CA, certificate, and key,
		 * which can be provided as a file path or file content.
		 */
		export interface MiddlewareSpecRateLimitRedisTlsPatch {
			/**
			 * CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
			 * The CA certificate is extracted from key `tls.ca` or `ca.crt`.
			 */
			caSecret?: pulumi.Input<string>;
			/**
			 * CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
			 * The client certificate is extracted from the keys `tls.crt` and `tls.key`.
			 */
			certSecret?: pulumi.Input<string>;
			/**
			 * InsecureSkipVerify defines whether the server certificates should be validated.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
		}

		/**
		 * SourceCriterion defines what criterion is used to group requests as originating from a common source.
		 * If several strategies are defined at the same time, an error will be raised.
		 * If none are set, the default is to use the request's remote address field (as an ipStrategy).
		 */
		export interface MiddlewareSpecRateLimitSourceCriterion {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitSourceCriterionIpStrategy>;
			/**
			 * RequestHeaderName defines the name of the header used to group incoming requests.
			 */
			requestHeaderName?: pulumi.Input<string>;
			/**
			 * RequestHost defines whether to consider the request Host as the source.
			 */
			requestHost?: pulumi.Input<boolean>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecRateLimitSourceCriterionIpStrategy {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/ipallowlist/#ipstrategy
		 */
		export interface MiddlewareSpecRateLimitSourceCriterionIpStrategyPatch {
			/**
			 * Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
			 */
			depth?: pulumi.Input<number>;
			/**
			 * ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
			 */
			excludedIPs?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
			 */
			ipv6Subnet?: pulumi.Input<number>;
		}

		/**
		 * SourceCriterion defines what criterion is used to group requests as originating from a common source.
		 * If several strategies are defined at the same time, an error will be raised.
		 * If none are set, the default is to use the request's remote address field (as an ipStrategy).
		 */
		export interface MiddlewareSpecRateLimitSourceCriterionPatch {
			ipStrategy?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareSpecRateLimitSourceCriterionIpStrategyPatch>;
			/**
			 * RequestHeaderName defines the name of the header used to group incoming requests.
			 */
			requestHeaderName?: pulumi.Input<string>;
			/**
			 * RequestHost defines whether to consider the request Host as the source.
			 */
			requestHost?: pulumi.Input<boolean>;
		}

		/**
		 * RedirectRegex holds the redirect regex middleware configuration.
		 * This middleware redirects a request using regex matching and replacement.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/redirectregex/#regex
		 */
		export interface MiddlewareSpecRedirectRegex {
			/**
			 * Permanent defines whether the redirection is permanent (308).
			 */
			permanent?: pulumi.Input<boolean>;
			/**
			 * Regex defines the regex used to match and capture elements from the request URL.
			 */
			regex?: pulumi.Input<string>;
			/**
			 * Replacement defines how to modify the URL to have the new target URL.
			 */
			replacement?: pulumi.Input<string>;
		}

		/**
		 * RedirectRegex holds the redirect regex middleware configuration.
		 * This middleware redirects a request using regex matching and replacement.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/redirectregex/#regex
		 */
		export interface MiddlewareSpecRedirectRegexPatch {
			/**
			 * Permanent defines whether the redirection is permanent (308).
			 */
			permanent?: pulumi.Input<boolean>;
			/**
			 * Regex defines the regex used to match and capture elements from the request URL.
			 */
			regex?: pulumi.Input<string>;
			/**
			 * Replacement defines how to modify the URL to have the new target URL.
			 */
			replacement?: pulumi.Input<string>;
		}

		/**
		 * RedirectScheme holds the redirect scheme middleware configuration.
		 * This middleware redirects requests from a scheme/port to another.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/redirectscheme/
		 */
		export interface MiddlewareSpecRedirectScheme {
			/**
			 * Permanent defines whether the redirection is permanent (308).
			 */
			permanent?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of the new URL.
			 */
			port?: pulumi.Input<string>;
			/**
			 * Scheme defines the scheme of the new URL.
			 */
			scheme?: pulumi.Input<string>;
		}

		/**
		 * RedirectScheme holds the redirect scheme middleware configuration.
		 * This middleware redirects requests from a scheme/port to another.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/redirectscheme/
		 */
		export interface MiddlewareSpecRedirectSchemePatch {
			/**
			 * Permanent defines whether the redirection is permanent (308).
			 */
			permanent?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of the new URL.
			 */
			port?: pulumi.Input<string>;
			/**
			 * Scheme defines the scheme of the new URL.
			 */
			scheme?: pulumi.Input<string>;
		}

		/**
		 * ReplacePath holds the replace path middleware configuration.
		 * This middleware replaces the path of the request URL and store the original path in an X-Replaced-Path header.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/replacepath/
		 */
		export interface MiddlewareSpecReplacePath {
			/**
			 * Path defines the path to use as replacement in the request URL.
			 */
			path?: pulumi.Input<string>;
		}

		/**
		 * ReplacePath holds the replace path middleware configuration.
		 * This middleware replaces the path of the request URL and store the original path in an X-Replaced-Path header.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/replacepath/
		 */
		export interface MiddlewareSpecReplacePathPatch {
			/**
			 * Path defines the path to use as replacement in the request URL.
			 */
			path?: pulumi.Input<string>;
		}

		/**
		 * ReplacePathRegex holds the replace path regex middleware configuration.
		 * This middleware replaces the path of a URL using regex matching and replacement.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/replacepathregex/
		 */
		export interface MiddlewareSpecReplacePathRegex {
			/**
			 * Regex defines the regular expression used to match and capture the path from the request URL.
			 */
			regex?: pulumi.Input<string>;
			/**
			 * Replacement defines the replacement path format, which can include captured variables.
			 */
			replacement?: pulumi.Input<string>;
		}

		/**
		 * ReplacePathRegex holds the replace path regex middleware configuration.
		 * This middleware replaces the path of a URL using regex matching and replacement.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/replacepathregex/
		 */
		export interface MiddlewareSpecReplacePathRegexPatch {
			/**
			 * Regex defines the regular expression used to match and capture the path from the request URL.
			 */
			regex?: pulumi.Input<string>;
			/**
			 * Replacement defines the replacement path format, which can include captured variables.
			 */
			replacement?: pulumi.Input<string>;
		}

		/**
		 * Retry holds the retry middleware configuration.
		 * This middleware reissues requests a given number of times to a backend server if that server does not reply.
		 * As soon as the server answers, the middleware stops retrying, regardless of the response status.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/retry/
		 */
		export interface MiddlewareSpecRetry {
			/**
			 * Attempts defines how many times the request should be retried.
			 */
			attempts?: pulumi.Input<number>;
			/**
			 * InitialInterval defines the first wait time in the exponential backoff series.
			 * The maximum interval is calculated as twice the initialInterval.
			 * If unspecified, requests will be retried immediately.
			 * The value of initialInterval should be provided in seconds or as a valid duration format,
			 * see https://pkg.go.dev/time#ParseDuration.
			 */
			initialInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Retry holds the retry middleware configuration.
		 * This middleware reissues requests a given number of times to a backend server if that server does not reply.
		 * As soon as the server answers, the middleware stops retrying, regardless of the response status.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/retry/
		 */
		export interface MiddlewareSpecRetryPatch {
			/**
			 * Attempts defines how many times the request should be retried.
			 */
			attempts?: pulumi.Input<number>;
			/**
			 * InitialInterval defines the first wait time in the exponential backoff series.
			 * The maximum interval is calculated as twice the initialInterval.
			 * If unspecified, requests will be retried immediately.
			 * The value of initialInterval should be provided in seconds or as a valid duration format,
			 * see https://pkg.go.dev/time#ParseDuration.
			 */
			initialInterval?: pulumi.Input<number | string>;
		}

		/**
		 * StripPrefix holds the strip prefix middleware configuration.
		 * This middleware removes the specified prefixes from the URL path.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/stripprefix/
		 */
		export interface MiddlewareSpecStripPrefix {
			/**
			 * Deprecated: ForceSlash option is deprecated, please remove any usage of this option.
			 * ForceSlash ensures that the resulting stripped path is not the empty string, by replacing it with / when necessary.
			 * Default: true.
			 */
			forceSlash?: pulumi.Input<boolean>;
			/**
			 * Prefixes defines the prefixes to strip from the request URL.
			 */
			prefixes?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * StripPrefix holds the strip prefix middleware configuration.
		 * This middleware removes the specified prefixes from the URL path.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/stripprefix/
		 */
		export interface MiddlewareSpecStripPrefixPatch {
			/**
			 * Deprecated: ForceSlash option is deprecated, please remove any usage of this option.
			 * ForceSlash ensures that the resulting stripped path is not the empty string, by replacing it with / when necessary.
			 * Default: true.
			 */
			forceSlash?: pulumi.Input<boolean>;
			/**
			 * Prefixes defines the prefixes to strip from the request URL.
			 */
			prefixes?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * StripPrefixRegex holds the strip prefix regex middleware configuration.
		 * This middleware removes the matching prefixes from the URL path.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/stripprefixregex/
		 */
		export interface MiddlewareSpecStripPrefixRegex {
			/**
			 * Regex defines the regular expression to match the path prefix from the request URL.
			 */
			regex?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * StripPrefixRegex holds the strip prefix regex middleware configuration.
		 * This middleware removes the matching prefixes from the URL path.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/http/stripprefixregex/
		 */
		export interface MiddlewareSpecStripPrefixRegexPatch {
			/**
			 * Regex defines the regular expression to match the path prefix from the request URL.
			 */
			regex?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * MiddlewareTCP is the CRD implementation of a Traefik TCP middleware.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/overview/
		 */
		export interface MiddlewareTCP {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"MiddlewareTCP">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareTCPSpec>;
		}

		/**
		 * MiddlewareTCPSpec defines the desired state of a MiddlewareTCP.
		 */
		export interface MiddlewareTCPSpec {
			inFlightConn?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareTCPSpecInFlightConn>;
			ipAllowList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareTCPSpecIpAllowList>;
			ipWhiteList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareTCPSpecIpWhiteList>;
		}

		/**
		 * InFlightConn defines the InFlightConn middleware configuration.
		 */
		export interface MiddlewareTCPSpecInFlightConn {
			/**
			 * Amount defines the maximum amount of allowed simultaneous connections.
			 * The middleware closes the connection if there are already amount connections opened.
			 */
			amount?: pulumi.Input<number>;
		}

		/**
		 * InFlightConn defines the InFlightConn middleware configuration.
		 */
		export interface MiddlewareTCPSpecInFlightConnPatch {
			/**
			 * Amount defines the maximum amount of allowed simultaneous connections.
			 * The middleware closes the connection if there are already amount connections opened.
			 */
			amount?: pulumi.Input<number>;
		}

		/**
		 * IPAllowList defines the IPAllowList middleware configuration.
		 * This middleware accepts/refuses connections based on the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/tcp/ipallowlist/
		 */
		export interface MiddlewareTCPSpecIpAllowList {
			/**
			 * SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * IPAllowList defines the IPAllowList middleware configuration.
		 * This middleware accepts/refuses connections based on the client IP.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/tcp/ipallowlist/
		 */
		export interface MiddlewareTCPSpecIpAllowListPatch {
			/**
			 * SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * IPWhiteList defines the IPWhiteList middleware configuration.
		 * This middleware accepts/refuses connections based on the client IP.
		 * Deprecated: please use IPAllowList instead.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/tcp/ipwhitelist/
		 */
		export interface MiddlewareTCPSpecIpWhiteList {
			/**
			 * SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * IPWhiteList defines the IPWhiteList middleware configuration.
		 * This middleware accepts/refuses connections based on the client IP.
		 * Deprecated: please use IPAllowList instead.
		 * More info: https://doc.traefik.io/traefik/v3.5/middlewares/tcp/ipwhitelist/
		 */
		export interface MiddlewareTCPSpecIpWhiteListPatch {
			/**
			 * SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
			 */
			sourceRange?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * MiddlewareTCPSpec defines the desired state of a MiddlewareTCP.
		 */
		export interface MiddlewareTCPSpecPatch {
			inFlightConn?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareTCPSpecInFlightConnPatch>;
			ipAllowList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareTCPSpecIpAllowListPatch>;
			ipWhiteList?: pulumi.Input<inputs.traefik.v1alpha1.MiddlewareTCPSpecIpWhiteListPatch>;
		}

		/**
		 * ServersTransport is the CRD implementation of a ServersTransport.
		 * If no serversTransport is specified, the default@internal will be used.
		 * The default@internal serversTransport is created from the static configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#serverstransport_1
		 */
		export interface ServersTransport {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"ServersTransport">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportSpec>;
		}

		/**
		 * ServersTransportSpec defines the desired state of a ServersTransport.
		 */
		export interface ServersTransportSpec {
			/**
			 * CertificatesSecrets defines a list of secret storing client certificates for mTLS.
			 */
			certificatesSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * DisableHTTP2 disables HTTP/2 for connections with backend servers.
			 */
			disableHTTP2?: pulumi.Input<boolean>;
			forwardingTimeouts?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportSpecForwardingTimeouts>;
			/**
			 * InsecureSkipVerify disables SSL certificate verification.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
			/**
			 * MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
			 */
			maxIdleConnsPerHost?: pulumi.Input<number>;
			/**
			 * PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
			 */
			peerCertURI?: pulumi.Input<string>;
			/**
			 * RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
			 */
			rootCAs?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.ServersTransportSpecRootCAs>[]
			>;
			/**
			 * RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
			 * Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
			 */
			rootCAsSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ServerName defines the server name used to contact the server.
			 */
			serverName?: pulumi.Input<string>;
			spiffe?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportSpecSpiffe>;
		}

		/**
		 * ForwardingTimeouts defines the timeouts for requests forwarded to the backend servers.
		 */
		export interface ServersTransportSpecForwardingTimeouts {
			/**
			 * DialTimeout is the amount of time to wait until a connection to a backend server can be established.
			 */
			dialTimeout?: pulumi.Input<number | string>;
			/**
			 * IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
			 */
			idleConnTimeout?: pulumi.Input<number | string>;
			/**
			 * PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
			 */
			pingTimeout?: pulumi.Input<number | string>;
			/**
			 * ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
			 */
			readIdleTimeout?: pulumi.Input<number | string>;
			/**
			 * ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
			 */
			responseHeaderTimeout?: pulumi.Input<number | string>;
		}

		/**
		 * ForwardingTimeouts defines the timeouts for requests forwarded to the backend servers.
		 */
		export interface ServersTransportSpecForwardingTimeoutsPatch {
			/**
			 * DialTimeout is the amount of time to wait until a connection to a backend server can be established.
			 */
			dialTimeout?: pulumi.Input<number | string>;
			/**
			 * IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
			 */
			idleConnTimeout?: pulumi.Input<number | string>;
			/**
			 * PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
			 */
			pingTimeout?: pulumi.Input<number | string>;
			/**
			 * ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
			 */
			readIdleTimeout?: pulumi.Input<number | string>;
			/**
			 * ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
			 */
			responseHeaderTimeout?: pulumi.Input<number | string>;
		}

		/**
		 * ServersTransportSpec defines the desired state of a ServersTransport.
		 */
		export interface ServersTransportSpecPatch {
			/**
			 * CertificatesSecrets defines a list of secret storing client certificates for mTLS.
			 */
			certificatesSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * DisableHTTP2 disables HTTP/2 for connections with backend servers.
			 */
			disableHTTP2?: pulumi.Input<boolean>;
			forwardingTimeouts?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportSpecForwardingTimeoutsPatch>;
			/**
			 * InsecureSkipVerify disables SSL certificate verification.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
			/**
			 * MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
			 */
			maxIdleConnsPerHost?: pulumi.Input<number>;
			/**
			 * PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
			 */
			peerCertURI?: pulumi.Input<string>;
			/**
			 * RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
			 */
			rootCAs?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.ServersTransportSpecRootCAsPatch>[]
			>;
			/**
			 * RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
			 * Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
			 */
			rootCAsSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ServerName defines the server name used to contact the server.
			 */
			serverName?: pulumi.Input<string>;
			spiffe?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportSpecSpiffePatch>;
		}

		/**
		 * RootCA defines a reference to a Secret or a ConfigMap that holds a CA certificate.
		 * If both a Secret and a ConfigMap reference are defined, the Secret reference takes precedence.
		 */
		export interface ServersTransportSpecRootCAs {
			/**
			 * ConfigMap defines the name of a ConfigMap that holds a CA certificate.
			 * The referenced ConfigMap must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			configMap?: pulumi.Input<string>;
			/**
			 * Secret defines the name of a Secret that holds a CA certificate.
			 * The referenced Secret must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * RootCA defines a reference to a Secret or a ConfigMap that holds a CA certificate.
		 * If both a Secret and a ConfigMap reference are defined, the Secret reference takes precedence.
		 */
		export interface ServersTransportSpecRootCAsPatch {
			/**
			 * ConfigMap defines the name of a ConfigMap that holds a CA certificate.
			 * The referenced ConfigMap must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			configMap?: pulumi.Input<string>;
			/**
			 * Secret defines the name of a Secret that holds a CA certificate.
			 * The referenced Secret must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * Spiffe defines the SPIFFE configuration.
		 */
		export interface ServersTransportSpecSpiffe {
			/**
			 * IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
			 */
			ids?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * TrustDomain defines the allowed SPIFFE trust domain.
			 */
			trustDomain?: pulumi.Input<string>;
		}

		/**
		 * Spiffe defines the SPIFFE configuration.
		 */
		export interface ServersTransportSpecSpiffePatch {
			/**
			 * IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
			 */
			ids?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * TrustDomain defines the allowed SPIFFE trust domain.
			 */
			trustDomain?: pulumi.Input<string>;
		}

		/**
		 * ServersTransportTCP is the CRD implementation of a TCPServersTransport.
		 * If no tcpServersTransport is specified, a default one named default@internal will be used.
		 * The default@internal tcpServersTransport can be configured in the static configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#serverstransport_3
		 */
		export interface ServersTransportTCP {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"ServersTransportTCP">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportTCPSpec>;
		}

		/**
		 * ServersTransportTCPSpec defines the desired state of a ServersTransportTCP.
		 */
		export interface ServersTransportTCPSpec {
			/**
			 * DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
			 */
			dialKeepAlive?: pulumi.Input<number | string>;
			/**
			 * DialTimeout is the amount of time to wait until a connection to a backend server can be established.
			 */
			dialTimeout?: pulumi.Input<number | string>;
			/**
			 * TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
			 */
			terminationDelay?: pulumi.Input<number | string>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportTCPSpecTls>;
		}

		/**
		 * ServersTransportTCPSpec defines the desired state of a ServersTransportTCP.
		 */
		export interface ServersTransportTCPSpecPatch {
			/**
			 * DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
			 */
			dialKeepAlive?: pulumi.Input<number | string>;
			/**
			 * DialTimeout is the amount of time to wait until a connection to a backend server can be established.
			 */
			dialTimeout?: pulumi.Input<number | string>;
			/**
			 * TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
			 */
			terminationDelay?: pulumi.Input<number | string>;
			tls?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportTCPSpecTlsPatch>;
		}

		/**
		 * TLS defines the TLS configuration
		 */
		export interface ServersTransportTCPSpecTls {
			/**
			 * CertificatesSecrets defines a list of secret storing client certificates for mTLS.
			 */
			certificatesSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * InsecureSkipVerify disables TLS certificate verification.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
			/**
			 * MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
			 * PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
			 */
			peerCertURI?: pulumi.Input<string>;
			/**
			 * RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
			 */
			rootCAs?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.ServersTransportTCPSpecTlsRootCAs>[]
			>;
			/**
			 * RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
			 * Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
			 */
			rootCAsSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ServerName defines the server name used to contact the server.
			 */
			serverName?: pulumi.Input<string>;
			spiffe?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportTCPSpecTlsSpiffe>;
		}

		/**
		 * TLS defines the TLS configuration
		 */
		export interface ServersTransportTCPSpecTlsPatch {
			/**
			 * CertificatesSecrets defines a list of secret storing client certificates for mTLS.
			 */
			certificatesSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * InsecureSkipVerify disables TLS certificate verification.
			 */
			insecureSkipVerify?: pulumi.Input<boolean>;
			/**
			 * MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
			 * PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
			 */
			peerCertURI?: pulumi.Input<string>;
			/**
			 * RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
			 */
			rootCAs?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.ServersTransportTCPSpecTlsRootCAsPatch>[]
			>;
			/**
			 * RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
			 * Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
			 */
			rootCAsSecrets?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * ServerName defines the server name used to contact the server.
			 */
			serverName?: pulumi.Input<string>;
			spiffe?: pulumi.Input<inputs.traefik.v1alpha1.ServersTransportTCPSpecTlsSpiffePatch>;
		}

		/**
		 * RootCA defines a reference to a Secret or a ConfigMap that holds a CA certificate.
		 * If both a Secret and a ConfigMap reference are defined, the Secret reference takes precedence.
		 */
		export interface ServersTransportTCPSpecTlsRootCAs {
			/**
			 * ConfigMap defines the name of a ConfigMap that holds a CA certificate.
			 * The referenced ConfigMap must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			configMap?: pulumi.Input<string>;
			/**
			 * Secret defines the name of a Secret that holds a CA certificate.
			 * The referenced Secret must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * RootCA defines a reference to a Secret or a ConfigMap that holds a CA certificate.
		 * If both a Secret and a ConfigMap reference are defined, the Secret reference takes precedence.
		 */
		export interface ServersTransportTCPSpecTlsRootCAsPatch {
			/**
			 * ConfigMap defines the name of a ConfigMap that holds a CA certificate.
			 * The referenced ConfigMap must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			configMap?: pulumi.Input<string>;
			/**
			 * Secret defines the name of a Secret that holds a CA certificate.
			 * The referenced Secret must contain a certificate under either a tls.ca or a ca.crt key.
			 */
			secret?: pulumi.Input<string>;
		}

		/**
		 * Spiffe defines the SPIFFE configuration.
		 */
		export interface ServersTransportTCPSpecTlsSpiffe {
			/**
			 * IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
			 */
			ids?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * TrustDomain defines the allowed SPIFFE trust domain.
			 */
			trustDomain?: pulumi.Input<string>;
		}

		/**
		 * Spiffe defines the SPIFFE configuration.
		 */
		export interface ServersTransportTCPSpecTlsSpiffePatch {
			/**
			 * IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
			 */
			ids?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * TrustDomain defines the allowed SPIFFE trust domain.
			 */
			trustDomain?: pulumi.Input<string>;
		}

		/**
		 * TLSOption is the CRD implementation of a Traefik TLS Option, allowing to configure some parameters of the TLS connection.
		 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#tls-options
		 */
		export interface TLSOption {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"TLSOption">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.TLSOptionSpec>;
		}

		/**
		 * TLSOptionSpec defines the desired state of a TLSOption.
		 */
		export interface TLSOptionSpec {
			/**
			 * ALPNProtocols defines the list of supported application level protocols for the TLS handshake, in order of preference.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#alpn-protocols
			 */
			alpnProtocols?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * CipherSuites defines the list of supported cipher suites for TLS versions up to TLS 1.2.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#cipher-suites
			 */
			cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
			clientAuth?: pulumi.Input<inputs.traefik.v1alpha1.TLSOptionSpecClientAuth>;
			/**
			 * CurvePreferences defines the preferred elliptic curves.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#curve-preferences
			 */
			curvePreferences?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * DisableSessionTickets disables TLS session resumption via session tickets.
			 */
			disableSessionTickets?: pulumi.Input<boolean>;
			/**
			 * MaxVersion defines the maximum TLS version that Traefik will accept.
			 * Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
			 * Default: None.
			 */
			maxVersion?: pulumi.Input<string>;
			/**
			 * MinVersion defines the minimum TLS version that Traefik will accept.
			 * Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
			 * Default: VersionTLS10.
			 */
			minVersion?: pulumi.Input<string>;
			/**
			 * PreferServerCipherSuites defines whether the server chooses a cipher suite among his own instead of among the client's.
			 * It is enabled automatically when minVersion or maxVersion is set.
			 * Deprecated: https://github.com/golang/go/issues/45430
			 */
			preferServerCipherSuites?: pulumi.Input<boolean>;
			/**
			 * SniStrict defines whether Traefik allows connections from clients connections that do not specify a server_name extension.
			 */
			sniStrict?: pulumi.Input<boolean>;
		}

		/**
		 * ClientAuth defines the server's policy for TLS Client Authentication.
		 */
		export interface TLSOptionSpecClientAuth {
			/**
			 * ClientAuthType defines the client authentication type to apply.
			 */
			clientAuthType?: pulumi.Input<string>;
			/**
			 * SecretNames defines the names of the referenced Kubernetes Secret storing certificate details.
			 */
			secretNames?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * ClientAuth defines the server's policy for TLS Client Authentication.
		 */
		export interface TLSOptionSpecClientAuthPatch {
			/**
			 * ClientAuthType defines the client authentication type to apply.
			 */
			clientAuthType?: pulumi.Input<string>;
			/**
			 * SecretNames defines the names of the referenced Kubernetes Secret storing certificate details.
			 */
			secretNames?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * TLSOptionSpec defines the desired state of a TLSOption.
		 */
		export interface TLSOptionSpecPatch {
			/**
			 * ALPNProtocols defines the list of supported application level protocols for the TLS handshake, in order of preference.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#alpn-protocols
			 */
			alpnProtocols?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * CipherSuites defines the list of supported cipher suites for TLS versions up to TLS 1.2.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#cipher-suites
			 */
			cipherSuites?: pulumi.Input<pulumi.Input<string>[]>;
			clientAuth?: pulumi.Input<inputs.traefik.v1alpha1.TLSOptionSpecClientAuthPatch>;
			/**
			 * CurvePreferences defines the preferred elliptic curves.
			 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#curve-preferences
			 */
			curvePreferences?: pulumi.Input<pulumi.Input<string>[]>;
			/**
			 * DisableSessionTickets disables TLS session resumption via session tickets.
			 */
			disableSessionTickets?: pulumi.Input<boolean>;
			/**
			 * MaxVersion defines the maximum TLS version that Traefik will accept.
			 * Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
			 * Default: None.
			 */
			maxVersion?: pulumi.Input<string>;
			/**
			 * MinVersion defines the minimum TLS version that Traefik will accept.
			 * Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
			 * Default: VersionTLS10.
			 */
			minVersion?: pulumi.Input<string>;
			/**
			 * PreferServerCipherSuites defines whether the server chooses a cipher suite among his own instead of among the client's.
			 * It is enabled automatically when minVersion or maxVersion is set.
			 * Deprecated: https://github.com/golang/go/issues/45430
			 */
			preferServerCipherSuites?: pulumi.Input<boolean>;
			/**
			 * SniStrict defines whether Traefik allows connections from clients connections that do not specify a server_name extension.
			 */
			sniStrict?: pulumi.Input<boolean>;
		}

		/**
		 * TLSStore is the CRD implementation of a Traefik TLS Store.
		 * For the time being, only the TLSStore named default is supported.
		 * This means that you cannot have two stores that are named default in different Kubernetes namespaces.
		 * More info: https://doc.traefik.io/traefik/v3.5/https/tls/#certificates-stores
		 */
		export interface TLSStore {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"TLSStore">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpec>;
		}

		/**
		 * TLSStoreSpec defines the desired state of a TLSStore.
		 */
		export interface TLSStoreSpec {
			/**
			 * Certificates is a list of secret names, each secret holding a key/certificate pair to add to the store.
			 */
			certificates?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecCertificates>[]
			>;
			defaultCertificate?: pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecDefaultCertificate>;
			defaultGeneratedCert?: pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecDefaultGeneratedCert>;
		}

		/**
		 * Certificate holds a secret name for the TLSStore resource.
		 */
		export interface TLSStoreSpecCertificates {
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
		}

		/**
		 * Certificate holds a secret name for the TLSStore resource.
		 */
		export interface TLSStoreSpecCertificatesPatch {
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
		}

		/**
		 * DefaultCertificate defines the default certificate configuration.
		 */
		export interface TLSStoreSpecDefaultCertificate {
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
		}

		/**
		 * DefaultCertificate defines the default certificate configuration.
		 */
		export interface TLSStoreSpecDefaultCertificatePatch {
			/**
			 * SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
			 */
			secretName?: pulumi.Input<string>;
		}

		/**
		 * DefaultGeneratedCert defines the default generated certificate configuration.
		 */
		export interface TLSStoreSpecDefaultGeneratedCert {
			domain?: pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecDefaultGeneratedCertDomain>;
			/**
			 * Resolver is the name of the resolver that will be used to issue the DefaultCertificate.
			 */
			resolver?: pulumi.Input<string>;
		}

		/**
		 * Domain is the domain definition for the DefaultCertificate.
		 */
		export interface TLSStoreSpecDefaultGeneratedCertDomain {
			/**
			 * Main defines the main domain name.
			 */
			main?: pulumi.Input<string>;
			/**
			 * SANs defines the subject alternative domain names.
			 */
			sans?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * Domain is the domain definition for the DefaultCertificate.
		 */
		export interface TLSStoreSpecDefaultGeneratedCertDomainPatch {
			/**
			 * Main defines the main domain name.
			 */
			main?: pulumi.Input<string>;
			/**
			 * SANs defines the subject alternative domain names.
			 */
			sans?: pulumi.Input<pulumi.Input<string>[]>;
		}

		/**
		 * DefaultGeneratedCert defines the default generated certificate configuration.
		 */
		export interface TLSStoreSpecDefaultGeneratedCertPatch {
			domain?: pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecDefaultGeneratedCertDomainPatch>;
			/**
			 * Resolver is the name of the resolver that will be used to issue the DefaultCertificate.
			 */
			resolver?: pulumi.Input<string>;
		}

		/**
		 * TLSStoreSpec defines the desired state of a TLSStore.
		 */
		export interface TLSStoreSpecPatch {
			/**
			 * Certificates is a list of secret names, each secret holding a key/certificate pair to add to the store.
			 */
			certificates?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecCertificatesPatch>[]
			>;
			defaultCertificate?: pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecDefaultCertificatePatch>;
			defaultGeneratedCert?: pulumi.Input<inputs.traefik.v1alpha1.TLSStoreSpecDefaultGeneratedCertPatch>;
		}

		/**
		 * TraefikService is the CRD implementation of a Traefik Service.
		 * TraefikService object allows to:
		 * - Apply weight to Services on load-balancing
		 * - Mirror traffic on services
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#kind-traefikservice
		 */
		export interface TraefikService {
			/**
			 * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
			 */
			apiVersion?: pulumi.Input<"traefik.io/v1alpha1">;
			/**
			 * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
			 */
			kind?: pulumi.Input<"TraefikService">;
			/**
			 * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
			 */
			metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
			spec?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpec>;
		}

		/**
		 * TraefikServiceSpec defines the desired state of a TraefikService.
		 */
		export interface TraefikServiceSpec {
			mirroring?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroring>;
			weighted?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeighted>;
		}

		/**
		 * Mirroring defines the Mirroring service configuration.
		 */
		export interface TraefikServiceSpecMirroring {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringHealthCheck>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * MaxBodySize defines the maximum size allowed for the body of the request.
			 * If the body is larger, the request is not mirrored.
			 * Default value is -1, which means unlimited size.
			 */
			maxBodySize?: pulumi.Input<number>;
			/**
			 * MirrorBody defines whether the body of the request should be mirrored.
			 * Default value is true.
			 */
			mirrorBody?: pulumi.Input<boolean>;
			/**
			 * Mirrors defines the list of mirrors where Traefik will duplicate the traffic.
			 */
			mirrors?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrors>[]
			>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringResponseForwarding>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringSticky>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface TraefikServiceSpecMirroringHealthCheck {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface TraefikServiceSpecMirroringHealthCheckPatch {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * MirrorService holds the mirror configuration.
		 */
		export interface TraefikServiceSpecMirroringMirrors {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsHealthCheck>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Percent defines the part of the traffic to mirror.
			 * Supported values: 0 to 100.
			 */
			percent?: pulumi.Input<number>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsResponseForwarding>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsSticky>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface TraefikServiceSpecMirroringMirrorsHealthCheck {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface TraefikServiceSpecMirroringMirrorsHealthCheckPatch {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * MirrorService holds the mirror configuration.
		 */
		export interface TraefikServiceSpecMirroringMirrorsPatch {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsHealthCheckPatch>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Percent defines the part of the traffic to mirror.
			 * Supported values: 0 to 100.
			 */
			percent?: pulumi.Input<number>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsResponseForwardingPatch>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsStickyPatch>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface TraefikServiceSpecMirroringMirrorsResponseForwarding {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface TraefikServiceSpecMirroringMirrorsResponseForwardingPatch {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface TraefikServiceSpecMirroringMirrorsSticky {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsStickyCookie>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecMirroringMirrorsStickyCookie {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecMirroringMirrorsStickyCookiePatch {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface TraefikServiceSpecMirroringMirrorsStickyPatch {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsStickyCookiePatch>;
		}

		/**
		 * Mirroring defines the Mirroring service configuration.
		 */
		export interface TraefikServiceSpecMirroringPatch {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringHealthCheckPatch>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * MaxBodySize defines the maximum size allowed for the body of the request.
			 * If the body is larger, the request is not mirrored.
			 * Default value is -1, which means unlimited size.
			 */
			maxBodySize?: pulumi.Input<number>;
			/**
			 * MirrorBody defines whether the body of the request should be mirrored.
			 * Default value is true.
			 */
			mirrorBody?: pulumi.Input<boolean>;
			/**
			 * Mirrors defines the list of mirrors where Traefik will duplicate the traffic.
			 */
			mirrors?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringMirrorsPatch>[]
			>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringResponseForwardingPatch>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringStickyPatch>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface TraefikServiceSpecMirroringResponseForwarding {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface TraefikServiceSpecMirroringResponseForwardingPatch {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface TraefikServiceSpecMirroringSticky {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringStickyCookie>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecMirroringStickyCookie {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecMirroringStickyCookiePatch {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface TraefikServiceSpecMirroringStickyPatch {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringStickyCookiePatch>;
		}

		/**
		 * TraefikServiceSpec defines the desired state of a TraefikService.
		 */
		export interface TraefikServiceSpecPatch {
			mirroring?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecMirroringPatch>;
			weighted?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedPatch>;
		}

		/**
		 * Weighted defines the Weighted Round Robin configuration.
		 */
		export interface TraefikServiceSpecWeighted {
			/**
			 * Services defines the list of Kubernetes Service and/or TraefikService to load-balance, with weight.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServices>[]
			>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedSticky>;
		}

		/**
		 * Weighted defines the Weighted Round Robin configuration.
		 */
		export interface TraefikServiceSpecWeightedPatch {
			/**
			 * Services defines the list of Kubernetes Service and/or TraefikService to load-balance, with weight.
			 */
			services?: pulumi.Input<
				pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesPatch>[]
			>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedStickyPatch>;
		}

		/**
		 * Service defines an upstream HTTP service to proxy traffic to.
		 */
		export interface TraefikServiceSpecWeightedServices {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesHealthCheck>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesResponseForwarding>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesSticky>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface TraefikServiceSpecWeightedServicesHealthCheck {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Healthcheck defines health checks for ExternalName services.
		 */
		export interface TraefikServiceSpecWeightedServicesHealthCheckPatch {
			/**
			 * FollowRedirects defines whether redirects should be followed during the health check calls.
			 * Default: true
			 */
			followRedirects?: pulumi.Input<boolean>;
			/**
			 * Headers defines custom headers to be sent to the health check endpoint.
			 */
			headers?: pulumi.Input<{ [key: string]: pulumi.Input<string> }>;
			/**
			 * Hostname defines the value of hostname in the Host header of the health check request.
			 */
			hostname?: pulumi.Input<string>;
			/**
			 * Interval defines the frequency of the health check calls for healthy targets.
			 * Default: 30s
			 */
			interval?: pulumi.Input<number | string>;
			/**
			 * Method defines the healthcheck method.
			 */
			method?: pulumi.Input<string>;
			/**
			 * Mode defines the health check mode.
			 * If defined to grpc, will use the gRPC health check protocol to probe the server.
			 * Default: http
			 */
			mode?: pulumi.Input<string>;
			/**
			 * Path defines the server URL path for the health check endpoint.
			 */
			path?: pulumi.Input<string>;
			/**
			 * Port defines the server URL port for the health check endpoint.
			 */
			port?: pulumi.Input<number>;
			/**
			 * Scheme replaces the server URL scheme for the health check endpoint.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * Status defines the expected HTTP status code of the response to the health check request.
			 */
			status?: pulumi.Input<number>;
			/**
			 * Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
			 * Default: 5s
			 */
			timeout?: pulumi.Input<number | string>;
			/**
			 * UnhealthyInterval defines the frequency of the health check calls for unhealthy targets.
			 * When UnhealthyInterval is not defined, it defaults to the Interval value.
			 * Default: 30s
			 */
			unhealthyInterval?: pulumi.Input<number | string>;
		}

		/**
		 * Service defines an upstream HTTP service to proxy traffic to.
		 */
		export interface TraefikServiceSpecWeightedServicesPatch {
			healthCheck?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesHealthCheckPatch>;
			/**
			 * Kind defines the kind of the Service.
			 */
			kind?: pulumi.Input<string>;
			/**
			 * Name defines the name of the referenced Kubernetes Service or TraefikService.
			 * The differentiation between the two is specified in the Kind field.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
			 */
			namespace?: pulumi.Input<string>;
			/**
			 * NativeLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
			 * The Kubernetes Service itself does load-balance to the pods.
			 * By default, NativeLB is false.
			 */
			nativeLB?: pulumi.Input<boolean>;
			/**
			 * NodePortLB controls, when creating the load-balancer,
			 * whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
			 * It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
			 * By default, NodePortLB is false.
			 */
			nodePortLB?: pulumi.Input<boolean>;
			/**
			 * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
			 * By default, passHostHeader is true.
			 */
			passHostHeader?: pulumi.Input<boolean>;
			/**
			 * Port defines the port of a Kubernetes Service.
			 * This can be a reference to a named port.
			 */
			port?: pulumi.Input<number | string>;
			responseForwarding?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesResponseForwardingPatch>;
			/**
			 * Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
			 * It defaults to https when Kubernetes Service port is 443, http otherwise.
			 */
			scheme?: pulumi.Input<string>;
			/**
			 * ServersTransport defines the name of ServersTransport resource to use.
			 * It allows to configure the transport between Traefik and your servers.
			 * Can only be used on a Kubernetes Service.
			 */
			serversTransport?: pulumi.Input<string>;
			sticky?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesStickyPatch>;
			/**
			 * Strategy defines the load balancing strategy between the servers.
			 * Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
			 * RoundRobin value is deprecated and supported for backward compatibility.
			 */
			strategy?: pulumi.Input<string>;
			/**
			 * Weight defines the weight and should only be specified when Name references a TraefikService object
			 * (and to be precise, one that embeds a Weighted Round Robin).
			 */
			weight?: pulumi.Input<number>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface TraefikServiceSpecWeightedServicesResponseForwarding {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
		 */
		export interface TraefikServiceSpecWeightedServicesResponseForwardingPatch {
			/**
			 * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
			 * A negative value means to flush immediately after each write to the client.
			 * This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
			 * for such responses, writes are flushed to the client immediately.
			 * Default: 100ms
			 */
			flushInterval?: pulumi.Input<string>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface TraefikServiceSpecWeightedServicesSticky {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesStickyCookie>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecWeightedServicesStickyCookie {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecWeightedServicesStickyCookiePatch {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Sticky defines the sticky sessions configuration.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/services/#sticky-sessions
		 */
		export interface TraefikServiceSpecWeightedServicesStickyPatch {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedServicesStickyCookiePatch>;
		}

		/**
		 * Sticky defines whether sticky sessions are enabled.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#stickiness-and-load-balancing
		 */
		export interface TraefikServiceSpecWeightedSticky {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedStickyCookie>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecWeightedStickyCookie {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Cookie defines the sticky cookie configuration.
		 */
		export interface TraefikServiceSpecWeightedStickyCookiePatch {
			/**
			 * Domain defines the host to which the cookie will be sent.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
			 */
			domain?: pulumi.Input<string>;
			/**
			 * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
			 */
			httpOnly?: pulumi.Input<boolean>;
			/**
			 * MaxAge defines the number of seconds until the cookie expires.
			 * When set to a negative number, the cookie expires immediately.
			 * When set to zero, the cookie never expires.
			 */
			maxAge?: pulumi.Input<number>;
			/**
			 * Name defines the Cookie name.
			 */
			name?: pulumi.Input<string>;
			/**
			 * Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
			 * When not provided the cookie will be sent on every request to the domain.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
			 */
			path?: pulumi.Input<string>;
			/**
			 * SameSite defines the same site policy.
			 * More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
			 */
			sameSite?: pulumi.Input<string>;
			/**
			 * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
			 */
			secure?: pulumi.Input<boolean>;
		}

		/**
		 * Sticky defines whether sticky sessions are enabled.
		 * More info: https://doc.traefik.io/traefik/v3.5/routing/providers/kubernetes-crd/#stickiness-and-load-balancing
		 */
		export interface TraefikServiceSpecWeightedStickyPatch {
			cookie?: pulumi.Input<inputs.traefik.v1alpha1.TraefikServiceSpecWeightedStickyCookiePatch>;
		}
	}
}
